{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BorderSet = void 0;\n\nvar Orientation_1 = require(\"../Orientation\");\n\nvar BorderNode_1 = require(\"./BorderNode\");\n\nvar BorderSet =\n/** @class */\nfunction () {\n  /** @internal */\n  function BorderSet(model) {\n    this._model = model;\n    this._borders = [];\n  }\n  /** @internal */\n\n\n  BorderSet._fromJson = function (json, model) {\n    var borderSet = new BorderSet(model);\n    borderSet._borders = json.map(function (borderJson) {\n      return BorderNode_1.BorderNode._fromJson(borderJson, model);\n    });\n    return borderSet;\n  };\n\n  BorderSet.prototype.getBorders = function () {\n    return this._borders;\n  };\n  /** @internal */\n\n\n  BorderSet.prototype._forEachNode = function (fn) {\n    for (var _i = 0, _a = this._borders; _i < _a.length; _i++) {\n      var borderNode = _a[_i];\n      fn(borderNode, 0);\n\n      for (var _b = 0, _c = borderNode.getChildren(); _b < _c.length; _b++) {\n        var node = _c[_b];\n\n        node._forEachNode(fn, 1);\n      }\n    }\n  };\n  /** @internal */\n\n\n  BorderSet.prototype._toJson = function () {\n    return this._borders.map(function (borderNode) {\n      return borderNode.toJson();\n    });\n  };\n  /** @internal */\n\n\n  BorderSet.prototype._layoutBorder = function (outerInnerRects, metrics) {\n    var rect = outerInnerRects.outer;\n\n    var rootRow = this._model.getRoot();\n\n    var height = Math.max(0, rect.height - rootRow.getMinHeight());\n    var width = Math.max(0, rect.width - rootRow.getMinWidth());\n    var sumHeight = 0;\n    var sumWidth = 0;\n    var adjustableHeight = 0;\n    var adjustableWidth = 0;\n\n    var showingBorders = this._borders.filter(function (border) {\n      return border.isShowing();\n    }); // sum size of borders to see they will fit\n\n\n    for (var _i = 0, showingBorders_1 = showingBorders; _i < showingBorders_1.length; _i++) {\n      var border = showingBorders_1[_i];\n\n      border._setAdjustedSize(border.getSize());\n\n      var visible = border.getSelected() !== -1;\n\n      if (border.getLocation().getOrientation() === Orientation_1.Orientation.HORZ) {\n        sumWidth += border.getBorderBarSize();\n\n        if (visible) {\n          width -= this._model.getSplitterSize();\n          sumWidth += border.getSize();\n          adjustableWidth += border.getSize();\n        }\n      } else {\n        sumHeight += border.getBorderBarSize();\n\n        if (visible) {\n          height -= this._model.getSplitterSize();\n          sumHeight += border.getSize();\n          adjustableHeight += border.getSize();\n        }\n      }\n    } // adjust border sizes if too large\n\n\n    var j = 0;\n    var adjusted = false;\n\n    while (sumWidth > width && adjustableWidth > 0 || sumHeight > height && adjustableHeight > 0) {\n      var border = showingBorders[j];\n\n      if (border.getSelected() !== -1) {\n        // visible\n        var size = border._getAdjustedSize();\n\n        if (sumWidth > width && adjustableWidth > 0 && border.getLocation().getOrientation() === Orientation_1.Orientation.HORZ && size > 0 && size > border.getMinSize()) {\n          border._setAdjustedSize(size - 1);\n\n          sumWidth--;\n          adjustableWidth--;\n          adjusted = true;\n        } else if (sumHeight > height && adjustableHeight > 0 && border.getLocation().getOrientation() === Orientation_1.Orientation.VERT && size > 0 && size > border.getMinSize()) {\n          border._setAdjustedSize(size - 1);\n\n          sumHeight--;\n          adjustableHeight--;\n          adjusted = true;\n        }\n      }\n\n      j = (j + 1) % showingBorders.length;\n\n      if (j === 0) {\n        if (adjusted) {\n          adjusted = false;\n        } else {\n          break;\n        }\n      }\n    }\n\n    for (var _a = 0, showingBorders_2 = showingBorders; _a < showingBorders_2.length; _a++) {\n      var border = showingBorders_2[_a];\n      outerInnerRects.outer = border._layoutBorderOuter(outerInnerRects.outer, metrics);\n    }\n\n    outerInnerRects.inner = outerInnerRects.outer;\n\n    for (var _b = 0, showingBorders_3 = showingBorders; _b < showingBorders_3.length; _b++) {\n      var border = showingBorders_3[_b];\n      outerInnerRects.inner = border._layoutBorderInner(outerInnerRects.inner, metrics);\n    }\n\n    return outerInnerRects;\n  };\n  /** @internal */\n\n\n  BorderSet.prototype._findDropTargetNode = function (dragNode, x, y) {\n    for (var _i = 0, _a = this._borders; _i < _a.length; _i++) {\n      var border = _a[_i];\n\n      if (border.isShowing()) {\n        var dropInfo = border.canDrop(dragNode, x, y);\n\n        if (dropInfo !== undefined) {\n          return dropInfo;\n        }\n      }\n    }\n\n    return undefined;\n  };\n\n  return BorderSet;\n}();\n\nexports.BorderSet = BorderSet;","map":{"version":3,"mappings":"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","names":["model","_model","_borders","BorderSet","json","borderSet","map","borderJson","_fromJson","fn","_i","borderNode","getChildren","_b","node","_forEachNode","toJson","outerInnerRects","metrics","rect","outer","rootRow","getRoot","height","Math","max","getMinHeight","width","getMinWidth","sumHeight","sumWidth","adjustableHeight","adjustableWidth","showingBorders","filter","border","isShowing","_setAdjustedSize","getSize","visible","getSelected","getLocation","getOrientation","Orientation_1","HORZ","getBorderBarSize","getSplitterSize","j","adjusted","size","_getAdjustedSize","getMinSize","VERT","length","_a","_layoutBorderOuter","inner","_layoutBorderInner","dragNode","x","y","dropInfo","canDrop","undefined","exports"],"sources":["C:\\Users\\mmorrone\\UnityProjects\\my-app\\node_modules\\flexlayout-react\\src\\model\\BorderSet.ts"],"sourcesContent":["import { DropInfo } from \"../DropInfo\";\nimport { Orientation } from \"../Orientation\";\nimport { Rect } from \"../Rect\";\nimport { BorderNode } from \"./BorderNode\";\nimport { IDraggable } from \"./IDraggable\";\nimport { Model, ILayoutMetrics } from \"./Model\";\nimport { Node } from \"./Node\";\n\nexport class BorderSet {\n    /** @internal */\n    static _fromJson(json: any, model: Model) {\n        const borderSet = new BorderSet(model);\n        borderSet._borders = json.map((borderJson: any) => BorderNode._fromJson(borderJson, model));\n        return borderSet;\n    }\n    /** @internal */\n    private _model: Model;\n    /** @internal */\n    private _borders: BorderNode[];\n\n    /** @internal */\n    constructor(model: Model) {\n        this._model = model;\n        this._borders = [];\n    }\n\n    getBorders() {\n        return this._borders;\n    }\n\n    /** @internal */\n    _forEachNode(fn: (node: Node, level: number) => void) {\n        for (const borderNode of this._borders) {\n            fn(borderNode, 0);\n            for (const node of borderNode.getChildren()) {\n                node._forEachNode(fn, 1);\n            }\n        }\n    }\n\n    /** @internal */\n    _toJson() {\n        return this._borders.map((borderNode) => borderNode.toJson());\n    }\n\n    /** @internal */\n    _layoutBorder(outerInnerRects: { inner: Rect; outer: Rect }, metrics: ILayoutMetrics) {\n        const rect = outerInnerRects.outer;\n        const rootRow = this._model.getRoot();\n        let height = Math.max(0, rect.height - rootRow.getMinHeight());\n        let width = Math.max(0, rect.width - rootRow.getMinWidth());\n        let sumHeight = 0;\n        let sumWidth = 0;\n        let adjustableHeight = 0;\n        let adjustableWidth = 0;\n\n        const showingBorders = this._borders.filter((border) => border.isShowing());\n\n        // sum size of borders to see they will fit\n        for (const border of showingBorders) {\n            border._setAdjustedSize(border.getSize());\n            const visible = border.getSelected() !== -1;\n            if (border.getLocation().getOrientation() === Orientation.HORZ) {\n                sumWidth += border.getBorderBarSize();\n                if (visible) {\n                    width -= this._model.getSplitterSize();\n                    sumWidth += border.getSize();\n                    adjustableWidth += border.getSize();\n                }\n            } else {\n                sumHeight += border.getBorderBarSize();\n                if (visible) {\n                    height -= this._model.getSplitterSize();\n                    sumHeight += border.getSize();\n                    adjustableHeight += border.getSize();\n                }\n            }\n        }\n\n        // adjust border sizes if too large\n        let j = 0;\n        let adjusted = false;\n        while ((sumWidth > width && adjustableWidth > 0) || (sumHeight > height && adjustableHeight > 0)) {\n            const border = showingBorders[j];\n            if (border.getSelected() !== -1) {\n                // visible\n                const size = border._getAdjustedSize();\n                if (sumWidth > width && adjustableWidth > 0 && border.getLocation().getOrientation() === Orientation.HORZ && size > 0\n                    && size > border.getMinSize()) {\n                    border._setAdjustedSize(size - 1);\n                    sumWidth--;\n                    adjustableWidth--;\n                    adjusted = true;\n                } else if (sumHeight > height && adjustableHeight > 0 && border.getLocation().getOrientation() === Orientation.VERT && size > 0\n                    && size > border.getMinSize()) {\n                    border._setAdjustedSize(size - 1);\n                    sumHeight--;\n                    adjustableHeight--;\n                    adjusted = true;\n                }\n            }\n            j = (j + 1) % showingBorders.length;\n            if (j === 0) {\n                if (adjusted) {\n                    adjusted = false;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        for (const border of showingBorders) {\n            outerInnerRects.outer = border._layoutBorderOuter(outerInnerRects.outer, metrics);\n        }\n\n        outerInnerRects.inner = outerInnerRects.outer;\n\n        for (const border of showingBorders) {\n            outerInnerRects.inner = border._layoutBorderInner(outerInnerRects.inner, metrics);\n        }\n        return outerInnerRects;\n    }\n\n    /** @internal */\n    _findDropTargetNode(dragNode: Node & IDraggable, x: number, y: number): DropInfo | undefined {\n        for (const border of this._borders) {\n            if (border.isShowing()) {\n                const dropInfo = border.canDrop(dragNode, x, y);\n                if (dropInfo !== undefined) {\n                    return dropInfo;\n                }\n            }\n        }\n        return undefined;\n    }\n}\n"]},"metadata":{},"sourceType":"script"}