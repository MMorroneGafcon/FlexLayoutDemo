{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RowNode = void 0;\n\nvar Attribute_1 = require(\"../Attribute\");\n\nvar AttributeDefinitions_1 = require(\"../AttributeDefinitions\");\n\nvar DockLocation_1 = require(\"../DockLocation\");\n\nvar DropInfo_1 = require(\"../DropInfo\");\n\nvar Orientation_1 = require(\"../Orientation\");\n\nvar Rect_1 = require(\"../Rect\");\n\nvar Types_1 = require(\"../Types\");\n\nvar BorderNode_1 = require(\"./BorderNode\");\n\nvar Node_1 = require(\"./Node\");\n\nvar SplitterNode_1 = require(\"./SplitterNode\");\n\nvar TabSetNode_1 = require(\"./TabSetNode\");\n\nvar RowNode =\n/** @class */\nfunction (_super) {\n  __extends(RowNode, _super);\n  /** @internal */\n\n\n  function RowNode(model, json) {\n    var _this = _super.call(this, model) || this;\n\n    _this._dirty = true;\n    _this._drawChildren = [];\n    _this._minHeight = 0;\n    _this._minWidth = 0;\n\n    RowNode._attributeDefinitions.fromJson(json, _this._attributes);\n\n    model._addNode(_this);\n\n    return _this;\n  }\n  /** @internal */\n\n\n  RowNode._fromJson = function (json, model) {\n    var newLayoutNode = new RowNode(model, json);\n\n    if (json.children != null) {\n      for (var _i = 0, _a = json.children; _i < _a.length; _i++) {\n        var jsonChild = _a[_i];\n\n        if (jsonChild.type === TabSetNode_1.TabSetNode.TYPE) {\n          var child = TabSetNode_1.TabSetNode._fromJson(jsonChild, model);\n\n          newLayoutNode._addChild(child);\n        } else {\n          var child = RowNode._fromJson(jsonChild, model);\n\n          newLayoutNode._addChild(child);\n        }\n      }\n    }\n\n    return newLayoutNode;\n  };\n  /** @internal */\n\n\n  RowNode._createAttributeDefinitions = function () {\n    var attributeDefinitions = new AttributeDefinitions_1.AttributeDefinitions();\n    attributeDefinitions.add(\"type\", RowNode.TYPE, true).setType(Attribute_1.Attribute.STRING).setFixed();\n    attributeDefinitions.add(\"id\", undefined).setType(Attribute_1.Attribute.STRING);\n    attributeDefinitions.add(\"weight\", 100).setType(Attribute_1.Attribute.NUMBER);\n    attributeDefinitions.add(\"width\", undefined).setType(Attribute_1.Attribute.NUMBER);\n    attributeDefinitions.add(\"height\", undefined).setType(Attribute_1.Attribute.NUMBER);\n    return attributeDefinitions;\n  };\n\n  RowNode.prototype.getWeight = function () {\n    return this._attributes.weight;\n  };\n\n  RowNode.prototype.getWidth = function () {\n    return this._getAttr(\"width\");\n  };\n\n  RowNode.prototype.getHeight = function () {\n    return this._getAttr(\"height\");\n  };\n  /** @internal */\n\n\n  RowNode.prototype._setWeight = function (weight) {\n    this._attributes.weight = weight;\n  };\n  /** @internal */\n\n\n  RowNode.prototype._layout = function (rect, metrics) {\n    _super.prototype._layout.call(this, rect, metrics);\n\n    var pixelSize = this._rect._getSize(this.getOrientation());\n\n    var totalWeight = 0;\n    var fixedPixels = 0;\n    var prefPixels = 0;\n    var totalPrefWeight = 0;\n\n    var drawChildren = this._getDrawChildren();\n\n    for (var _i = 0, drawChildren_1 = drawChildren; _i < drawChildren_1.length; _i++) {\n      var child = drawChildren_1[_i];\n\n      var prefSize = child._getPrefSize(this.getOrientation());\n\n      if (child._isFixed()) {\n        if (prefSize !== undefined) {\n          fixedPixels += prefSize;\n        }\n      } else {\n        if (prefSize === undefined) {\n          totalWeight += child.getWeight();\n        } else {\n          prefPixels += prefSize;\n          totalPrefWeight += child.getWeight();\n        }\n      }\n    }\n\n    var resizePreferred = false;\n    var availablePixels = pixelSize - fixedPixels - prefPixels;\n\n    if (availablePixels < 0) {\n      availablePixels = pixelSize - fixedPixels;\n      resizePreferred = true;\n      totalWeight += totalPrefWeight;\n    } // assign actual pixel sizes\n\n\n    var totalSizeGiven = 0;\n    var variableSize = 0;\n\n    for (var _a = 0, drawChildren_2 = drawChildren; _a < drawChildren_2.length; _a++) {\n      var child = drawChildren_2[_a];\n\n      var prefSize = child._getPrefSize(this.getOrientation());\n\n      if (child._isFixed()) {\n        if (prefSize !== undefined) {\n          child._setTempSize(prefSize);\n        }\n      } else {\n        if (prefSize == null || resizePreferred) {\n          if (totalWeight === 0) {\n            child._setTempSize(0);\n          } else {\n            var minSize = child.getMinSize(this.getOrientation());\n            var size = Math.floor(availablePixels * (child.getWeight() / totalWeight));\n\n            child._setTempSize(Math.max(minSize, size));\n          }\n\n          variableSize += child._getTempSize();\n        } else {\n          child._setTempSize(prefSize);\n        }\n      }\n\n      totalSizeGiven += child._getTempSize();\n    } // adjust sizes to exactly fit\n\n\n    if (variableSize > 0) {\n      while (totalSizeGiven < pixelSize) {\n        for (var _b = 0, drawChildren_3 = drawChildren; _b < drawChildren_3.length; _b++) {\n          var child = drawChildren_3[_b];\n\n          if (!(child instanceof SplitterNode_1.SplitterNode)) {\n            var prefSize = child._getPrefSize(this.getOrientation());\n\n            if (!child._isFixed() && (prefSize === undefined || resizePreferred) && totalSizeGiven < pixelSize) {\n              child._setTempSize(child._getTempSize() + 1);\n\n              totalSizeGiven++;\n            }\n          }\n        }\n      } // decrease size using nodes not at there minimum\n\n\n      while (totalSizeGiven > pixelSize) {\n        var changed = false;\n\n        for (var _c = 0, drawChildren_4 = drawChildren; _c < drawChildren_4.length; _c++) {\n          var child = drawChildren_4[_c];\n\n          if (!(child instanceof SplitterNode_1.SplitterNode)) {\n            var minSize = child.getMinSize(this.getOrientation());\n\n            var size = child._getTempSize();\n\n            if (size > minSize && totalSizeGiven > pixelSize) {\n              child._setTempSize(child._getTempSize() - 1);\n\n              totalSizeGiven--;\n              changed = true;\n            }\n          }\n        }\n\n        if (!changed) {\n          // all children are at min values\n          break;\n        }\n      } // if still too big then simply reduce all nodes until fits\n\n\n      while (totalSizeGiven > pixelSize) {\n        var changed = false;\n\n        for (var _d = 0, drawChildren_5 = drawChildren; _d < drawChildren_5.length; _d++) {\n          var child = drawChildren_5[_d];\n\n          if (!(child instanceof SplitterNode_1.SplitterNode)) {\n            var size = child._getTempSize();\n\n            if (size > 0 && totalSizeGiven > pixelSize) {\n              child._setTempSize(child._getTempSize() - 1);\n\n              totalSizeGiven--;\n              changed = true;\n            }\n          }\n        }\n\n        if (!changed) {\n          // all children are at 0 values\n          break;\n        }\n      }\n    } // layout children\n\n\n    var p = 0;\n\n    for (var _e = 0, drawChildren_6 = drawChildren; _e < drawChildren_6.length; _e++) {\n      var child = drawChildren_6[_e];\n\n      if (this.getOrientation() === Orientation_1.Orientation.HORZ) {\n        child._layout(new Rect_1.Rect(this._rect.x + p, this._rect.y, child._getTempSize(), this._rect.height), metrics);\n      } else {\n        child._layout(new Rect_1.Rect(this._rect.x, this._rect.y + p, this._rect.width, child._getTempSize()), metrics);\n      }\n\n      p += child._getTempSize();\n    }\n\n    return true;\n  };\n  /** @internal */\n\n\n  RowNode.prototype._getSplitterBounds = function (splitterNode, useMinSize) {\n    if (useMinSize === void 0) {\n      useMinSize = false;\n    }\n\n    var pBounds = [0, 0];\n\n    var drawChildren = this._getDrawChildren();\n\n    var p = drawChildren.indexOf(splitterNode);\n    var node1 = drawChildren[p - 1];\n    var node2 = drawChildren[p + 1];\n\n    if (this.getOrientation() === Orientation_1.Orientation.HORZ) {\n      var minSize1 = useMinSize ? node1.getMinWidth() : 0;\n      var minSize2 = useMinSize ? node2.getMinWidth() : 0;\n      pBounds[0] = node1.getRect().x + minSize1;\n      pBounds[1] = node2.getRect().getRight() - splitterNode.getWidth() - minSize2;\n    } else {\n      var minSize1 = useMinSize ? node1.getMinHeight() : 0;\n      var minSize2 = useMinSize ? node2.getMinHeight() : 0;\n      pBounds[0] = node1.getRect().y + minSize1;\n      pBounds[1] = node2.getRect().getBottom() - splitterNode.getHeight() - minSize2;\n    }\n\n    return pBounds;\n  };\n  /** @internal */\n\n\n  RowNode.prototype._calculateSplit = function (splitter, splitterPos) {\n    var rtn;\n\n    var drawChildren = this._getDrawChildren();\n\n    var p = drawChildren.indexOf(splitter);\n\n    var pBounds = this._getSplitterBounds(splitter);\n\n    var weightedLength = drawChildren[p - 1].getWeight() + drawChildren[p + 1].getWeight();\n    var pixelWidth1 = Math.max(0, splitterPos - pBounds[0]);\n    var pixelWidth2 = Math.max(0, pBounds[1] - splitterPos);\n\n    if (pixelWidth1 + pixelWidth2 > 0) {\n      var weight1 = pixelWidth1 * weightedLength / (pixelWidth1 + pixelWidth2);\n      var weight2 = pixelWidth2 * weightedLength / (pixelWidth1 + pixelWidth2);\n      rtn = {\n        node1Id: drawChildren[p - 1].getId(),\n        weight1: weight1,\n        pixelWidth1: pixelWidth1,\n        node2Id: drawChildren[p + 1].getId(),\n        weight2: weight2,\n        pixelWidth2: pixelWidth2\n      };\n    }\n\n    return rtn;\n  };\n  /** @internal */\n\n\n  RowNode.prototype._getDrawChildren = function () {\n    if (this._dirty) {\n      this._drawChildren = [];\n\n      for (var i = 0; i < this._children.length; i++) {\n        var child = this._children[i];\n\n        if (i !== 0) {\n          var newSplitter = new SplitterNode_1.SplitterNode(this._model);\n\n          newSplitter._setParent(this);\n\n          this._drawChildren.push(newSplitter);\n        }\n\n        this._drawChildren.push(child);\n      }\n\n      this._dirty = false;\n    }\n\n    return this._drawChildren;\n  };\n  /** @internal */\n\n\n  RowNode.prototype.getMinSize = function (orientation) {\n    if (orientation === Orientation_1.Orientation.HORZ) {\n      return this.getMinWidth();\n    } else {\n      return this.getMinHeight();\n    }\n  };\n  /** @internal */\n\n\n  RowNode.prototype.getMinWidth = function () {\n    return this._minWidth;\n  };\n  /** @internal */\n\n\n  RowNode.prototype.getMinHeight = function () {\n    return this._minHeight;\n  };\n  /** @internal */\n\n\n  RowNode.prototype.calcMinSize = function () {\n    this._minHeight = 0;\n    this._minWidth = 0;\n    var first = true;\n\n    for (var _i = 0, _a = this._children; _i < _a.length; _i++) {\n      var child = _a[_i];\n      var c = child;\n\n      if (c instanceof RowNode) {\n        c.calcMinSize();\n      }\n\n      if (this.getOrientation() === Orientation_1.Orientation.VERT) {\n        this._minHeight += c.getMinHeight();\n\n        if (!first) {\n          this._minHeight += this._model.getSplitterSize();\n        }\n\n        this._minWidth = Math.max(this._minWidth, c.getMinWidth());\n      } else {\n        this._minWidth += c.getMinWidth();\n\n        if (!first) {\n          this._minWidth += this._model.getSplitterSize();\n        }\n\n        this._minHeight = Math.max(this._minHeight, c.getMinHeight());\n      }\n\n      first = false;\n    }\n  };\n  /** @internal */\n\n\n  RowNode.prototype._tidy = function () {\n    var i = 0;\n\n    while (i < this._children.length) {\n      var child = this._children[i];\n\n      if (child instanceof RowNode) {\n        child._tidy();\n\n        var childChildren = child.getChildren();\n\n        if (childChildren.length === 0) {\n          this._removeChild(child);\n        } else if (childChildren.length === 1) {\n          // hoist child/children up to this level\n          var subchild = childChildren[0];\n\n          this._removeChild(child);\n\n          if (subchild instanceof RowNode) {\n            var subChildrenTotal = 0;\n            var subChildChildren = subchild.getChildren();\n\n            for (var _i = 0, subChildChildren_1 = subChildChildren; _i < subChildChildren_1.length; _i++) {\n              var ssc = subChildChildren_1[_i];\n              var subsubChild = ssc;\n              subChildrenTotal += subsubChild.getWeight();\n            }\n\n            for (var j = 0; j < subChildChildren.length; j++) {\n              var subsubChild = subChildChildren[j];\n\n              subsubChild._setWeight(child.getWeight() * subsubChild.getWeight() / subChildrenTotal);\n\n              this._addChild(subsubChild, i + j);\n            }\n          } else {\n            subchild._setWeight(child.getWeight());\n\n            this._addChild(subchild, i);\n          }\n        } else {\n          i++;\n        }\n      } else if (child instanceof TabSetNode_1.TabSetNode && child.getChildren().length === 0) {\n        if (child.isEnableDeleteWhenEmpty()) {\n          this._removeChild(child);\n\n          if (child === this._model.getMaximizedTabset()) {\n            this._model._setMaximizedTabset(undefined);\n          }\n        } else {\n          i++;\n        }\n      } else {\n        i++;\n      }\n    } // add tabset into empty root\n\n\n    if (this === this._model.getRoot() && this._children.length === 0) {\n      var callback = this._model._getOnCreateTabSet();\n\n      var attrs = callback ? callback() : {};\n      attrs = __assign(__assign({}, attrs), {\n        selected: -1\n      });\n      var child = new TabSetNode_1.TabSetNode(this._model, attrs);\n\n      this._model._setActiveTabset(child);\n\n      this._addChild(child);\n    }\n  };\n  /** @internal */\n\n\n  RowNode.prototype.canDrop = function (dragNode, x, y) {\n    var yy = y - this._rect.y;\n    var xx = x - this._rect.x;\n    var w = this._rect.width;\n    var h = this._rect.height;\n    var margin = 10; // height of edge rect\n\n    var half = 50; // half width of edge rect\n\n    var dropInfo;\n\n    if (this._model.isEnableEdgeDock() && this._parent === undefined) {\n      // _root row\n      if (x < this._rect.x + margin && yy > h / 2 - half && yy < h / 2 + half) {\n        var dockLocation = DockLocation_1.DockLocation.LEFT;\n        var outlineRect = dockLocation.getDockRect(this._rect);\n        outlineRect.width = outlineRect.width / 2;\n        dropInfo = new DropInfo_1.DropInfo(this, outlineRect, dockLocation, -1, Types_1.CLASSES.FLEXLAYOUT__OUTLINE_RECT_EDGE);\n      } else if (x > this._rect.getRight() - margin && yy > h / 2 - half && yy < h / 2 + half) {\n        var dockLocation = DockLocation_1.DockLocation.RIGHT;\n        var outlineRect = dockLocation.getDockRect(this._rect);\n        outlineRect.width = outlineRect.width / 2;\n        outlineRect.x += outlineRect.width;\n        dropInfo = new DropInfo_1.DropInfo(this, outlineRect, dockLocation, -1, Types_1.CLASSES.FLEXLAYOUT__OUTLINE_RECT_EDGE);\n      } else if (y < this._rect.y + margin && xx > w / 2 - half && xx < w / 2 + half) {\n        var dockLocation = DockLocation_1.DockLocation.TOP;\n        var outlineRect = dockLocation.getDockRect(this._rect);\n        outlineRect.height = outlineRect.height / 2;\n        dropInfo = new DropInfo_1.DropInfo(this, outlineRect, dockLocation, -1, Types_1.CLASSES.FLEXLAYOUT__OUTLINE_RECT_EDGE);\n      } else if (y > this._rect.getBottom() - margin && xx > w / 2 - half && xx < w / 2 + half) {\n        var dockLocation = DockLocation_1.DockLocation.BOTTOM;\n        var outlineRect = dockLocation.getDockRect(this._rect);\n        outlineRect.height = outlineRect.height / 2;\n        outlineRect.y += outlineRect.height;\n        dropInfo = new DropInfo_1.DropInfo(this, outlineRect, dockLocation, -1, Types_1.CLASSES.FLEXLAYOUT__OUTLINE_RECT_EDGE);\n      }\n\n      if (dropInfo !== undefined) {\n        if (!dragNode._canDockInto(dragNode, dropInfo)) {\n          return undefined;\n        }\n      }\n    }\n\n    return dropInfo;\n  };\n  /** @internal */\n\n\n  RowNode.prototype.drop = function (dragNode, location, index) {\n    var dockLocation = location;\n    var parent = dragNode.getParent();\n\n    if (parent) {\n      parent._removeChild(dragNode);\n    }\n\n    if (parent !== undefined && parent.getType() === TabSetNode_1.TabSetNode.TYPE) {\n      parent._setSelected(0);\n    }\n\n    if (parent !== undefined && parent.getType() === BorderNode_1.BorderNode.TYPE) {\n      parent._setSelected(-1);\n    }\n\n    var tabSet;\n\n    if (dragNode instanceof TabSetNode_1.TabSetNode) {\n      tabSet = dragNode;\n    } else {\n      var callback = this._model._getOnCreateTabSet();\n\n      tabSet = new TabSetNode_1.TabSetNode(this._model, callback ? callback(dragNode) : {});\n\n      tabSet._addChild(dragNode);\n    }\n\n    var size = this._children.reduce(function (sum, child) {\n      return sum + child.getWeight();\n    }, 0);\n\n    if (size === 0) {\n      size = 100;\n    }\n\n    tabSet._setWeight(size / 3);\n\n    var horz = !this._model.isRootOrientationVertical();\n\n    if (horz && dockLocation === DockLocation_1.DockLocation.LEFT || !horz && dockLocation === DockLocation_1.DockLocation.TOP) {\n      this._addChild(tabSet, 0);\n    } else if (horz && dockLocation === DockLocation_1.DockLocation.RIGHT || !horz && dockLocation === DockLocation_1.DockLocation.BOTTOM) {\n      this._addChild(tabSet);\n    } else if (horz && dockLocation === DockLocation_1.DockLocation.TOP || !horz && dockLocation === DockLocation_1.DockLocation.LEFT) {\n      var vrow = new RowNode(this._model, {});\n      var hrow = new RowNode(this._model, {});\n\n      hrow._setWeight(75);\n\n      tabSet._setWeight(25);\n\n      for (var _i = 0, _a = this._children; _i < _a.length; _i++) {\n        var child = _a[_i];\n\n        hrow._addChild(child);\n      }\n\n      this._removeAll();\n\n      vrow._addChild(tabSet);\n\n      vrow._addChild(hrow);\n\n      this._addChild(vrow);\n    } else if (horz && dockLocation === DockLocation_1.DockLocation.BOTTOM || !horz && dockLocation === DockLocation_1.DockLocation.RIGHT) {\n      var vrow = new RowNode(this._model, {});\n      var hrow = new RowNode(this._model, {});\n\n      hrow._setWeight(75);\n\n      tabSet._setWeight(25);\n\n      for (var _b = 0, _c = this._children; _b < _c.length; _b++) {\n        var child = _c[_b];\n\n        hrow._addChild(child);\n      }\n\n      this._removeAll();\n\n      vrow._addChild(hrow);\n\n      vrow._addChild(tabSet);\n\n      this._addChild(vrow);\n    }\n\n    this._model._setActiveTabset(tabSet);\n\n    this._model._tidy();\n  };\n\n  RowNode.prototype.toJson = function () {\n    var json = {};\n\n    RowNode._attributeDefinitions.toJson(json, this._attributes);\n\n    json.children = [];\n\n    for (var _i = 0, _a = this._children; _i < _a.length; _i++) {\n      var child = _a[_i];\n      json.children.push(child.toJson());\n    }\n\n    return json;\n  };\n\n  RowNode.prototype.isEnableDrop = function () {\n    return true;\n  };\n  /** @internal */\n\n\n  RowNode.prototype._getPrefSize = function (orientation) {\n    var prefSize = this.getWidth();\n\n    if (orientation === Orientation_1.Orientation.VERT) {\n      prefSize = this.getHeight();\n    }\n\n    return prefSize;\n  };\n  /** @internal */\n\n\n  RowNode.prototype._getAttributeDefinitions = function () {\n    return RowNode._attributeDefinitions;\n  };\n  /** @internal */\n\n\n  RowNode.prototype._updateAttrs = function (json) {\n    RowNode._attributeDefinitions.update(json, this._attributes);\n  };\n  /** @internal */\n\n\n  RowNode.getAttributeDefinitions = function () {\n    return RowNode._attributeDefinitions;\n  };\n\n  RowNode.TYPE = \"row\";\n  /** @internal */\n\n  RowNode._attributeDefinitions = RowNode._createAttributeDefinitions();\n  return RowNode;\n}(Node_1.Node);\n\nexports.RowNode = RowNode;","map":{"version":3,"mappings":"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","names":["__extends","model","json","_super","_this","_dirty","_drawChildren","_minHeight","_minWidth","RowNode","_attributeDefinitions","fromJson","_attributes","_addNode","newLayoutNode","children","_i","jsonChild","type","TabSetNode_1","TYPE","child","_fromJson","_addChild","attributeDefinitions","AttributeDefinitions_1","add","setType","Attribute_1","STRING","setFixed","undefined","NUMBER","weight","_getAttr","rect","metrics","_layout","call","pixelSize","_rect","_getSize","getOrientation","totalWeight","fixedPixels","prefPixels","totalPrefWeight","drawChildren","_getDrawChildren","prefSize","_getPrefSize","_isFixed","getWeight","resizePreferred","availablePixels","totalSizeGiven","variableSize","_a","_setTempSize","minSize","getMinSize","size","Math","floor","max","_getTempSize","_b","SplitterNode_1","changed","_c","_d","p","_e","Orientation_1","HORZ","Rect_1","x","y","height","width","splitterNode","useMinSize","pBounds","indexOf","node1","node2","minSize1","getMinWidth","minSize2","getRect","getRight","getWidth","getMinHeight","getBottom","getHeight","splitter","splitterPos","rtn","_getSplitterBounds","weightedLength","pixelWidth1","pixelWidth2","weight1","weight2","node1Id","getId","node2Id","i","_children","length","newSplitter","_model","_setParent","push","orientation","first","c","calcMinSize","VERT","getSplitterSize","_tidy","childChildren","getChildren","_removeChild","subchild","subChildrenTotal","subChildChildren","ssc","subsubChild","j","_setWeight","isEnableDeleteWhenEmpty","getMaximizedTabset","_setMaximizedTabset","getRoot","callback","_getOnCreateTabSet","attrs","selected","_setActiveTabset","dragNode","yy","xx","w","h","margin","half","dropInfo","isEnableEdgeDock","_parent","dockLocation","DockLocation_1","LEFT","outlineRect","getDockRect","DropInfo_1","Types_1","FLEXLAYOUT__OUTLINE_RECT_EDGE","RIGHT","TOP","BOTTOM","_canDockInto","location","index","parent","getParent","getType","_setSelected","BorderNode_1","tabSet","reduce","sum","horz","isRootOrientationVertical","vrow","hrow","_removeAll","toJson","update","_createAttributeDefinitions","Node_1","exports"],"sources":["C:\\Users\\mmorrone\\UnityProjects\\my-app\\node_modules\\flexlayout-react\\src\\model\\RowNode.ts"],"sourcesContent":["import { TabNode } from \"./TabNode\";\nimport { Attribute } from \"../Attribute\";\nimport { AttributeDefinitions } from \"../AttributeDefinitions\";\nimport { DockLocation } from \"../DockLocation\";\nimport { DropInfo } from \"../DropInfo\";\nimport { Orientation } from \"../Orientation\";\nimport { Rect } from \"../Rect\";\nimport { CLASSES } from \"../Types\";\nimport { BorderNode } from \"./BorderNode\";\nimport { IDraggable } from \"./IDraggable\";\nimport { IDropTarget } from \"./IDropTarget\";\nimport { IJsonRowNode } from \"./IJsonModel\";\nimport { Model, ILayoutMetrics } from \"./Model\";\nimport { Node } from \"./Node\";\nimport { SplitterNode } from \"./SplitterNode\";\nimport { TabSetNode } from \"./TabSetNode\";\n\nexport class RowNode extends Node implements IDropTarget {\n    static readonly TYPE = \"row\";\n\n    /** @internal */\n    static _fromJson(json: any, model: Model) {\n        const newLayoutNode = new RowNode(model, json);\n\n        if (json.children != null) {\n            for (const jsonChild of json.children) {\n                if (jsonChild.type === TabSetNode.TYPE) {\n                    const child = TabSetNode._fromJson(jsonChild, model);\n                    newLayoutNode._addChild(child);\n                } else {\n                    const child = RowNode._fromJson(jsonChild, model);\n                    newLayoutNode._addChild(child);\n                }\n            }\n        }\n\n        return newLayoutNode;\n    }\n    /** @internal */\n    private static _attributeDefinitions: AttributeDefinitions = RowNode._createAttributeDefinitions();\n\n    /** @internal */\n    private static _createAttributeDefinitions(): AttributeDefinitions {\n        const attributeDefinitions = new AttributeDefinitions();\n        attributeDefinitions.add(\"type\", RowNode.TYPE, true).setType(Attribute.STRING).setFixed();\n        attributeDefinitions.add(\"id\", undefined).setType(Attribute.STRING);\n\n        attributeDefinitions.add(\"weight\", 100).setType(Attribute.NUMBER);\n        attributeDefinitions.add(\"width\", undefined).setType(Attribute.NUMBER);\n        attributeDefinitions.add(\"height\", undefined).setType(Attribute.NUMBER);\n\n        return attributeDefinitions;\n    }\n    /** @internal */\n    private _drawChildren: (TabSetNode | RowNode | SplitterNode)[];\n    /** @internal */\n    private _minHeight: number;\n    /** @internal */\n    private _minWidth: number;\n\n    /** @internal */\n    constructor(model: Model, json: any) {\n        super(model);\n\n        this._dirty = true;\n        this._drawChildren = [];\n        this._minHeight = 0;\n        this._minWidth = 0;\n        RowNode._attributeDefinitions.fromJson(json, this._attributes);\n        model._addNode(this);\n    }\n\n    getWeight() {\n        return this._attributes.weight as number;\n    }\n\n    getWidth() {\n        return this._getAttr(\"width\") as number | undefined;\n    }\n\n    getHeight() {\n        return this._getAttr(\"height\") as number | undefined;\n    }\n\n    /** @internal */\n    _setWeight(weight: number) {\n        this._attributes.weight = weight;\n    }\n\n    /** @internal */\n    _layout(rect: Rect, metrics: ILayoutMetrics) {\n        super._layout(rect, metrics);\n\n        const pixelSize = this._rect._getSize(this.getOrientation());\n\n        let totalWeight = 0;\n        let fixedPixels = 0;\n        let prefPixels = 0;\n        let totalPrefWeight = 0;\n        const drawChildren = this._getDrawChildren() as (RowNode | TabSetNode | SplitterNode)[];\n\n        for (const child of drawChildren) {\n            const prefSize = child._getPrefSize(this.getOrientation());\n            if (child._isFixed()) {\n                if (prefSize !== undefined) {\n                    fixedPixels += prefSize;\n                }\n            } else {\n                if (prefSize === undefined) {\n                    totalWeight += child.getWeight();\n                } else {\n                    prefPixels += prefSize;\n                    totalPrefWeight += child.getWeight();\n                }\n            }\n        }\n\n        let resizePreferred = false;\n        let availablePixels = pixelSize - fixedPixels - prefPixels;\n        if (availablePixels < 0) {\n            availablePixels = pixelSize - fixedPixels;\n            resizePreferred = true;\n            totalWeight += totalPrefWeight;\n        }\n        // assign actual pixel sizes\n        let totalSizeGiven = 0;\n        let variableSize = 0;\n        for (const child of drawChildren) {\n            const prefSize = child._getPrefSize(this.getOrientation());\n            if (child._isFixed()) {\n                if (prefSize !== undefined) {\n                    child._setTempSize(prefSize);\n                }\n            } else {\n                if (prefSize == null || resizePreferred) {\n                    if (totalWeight === 0) {\n                        child._setTempSize(0);\n                    } else {\n                        const minSize = child.getMinSize(this.getOrientation());\n                        const size = Math.floor(availablePixels * (child.getWeight() / totalWeight));\n                        child._setTempSize(Math.max(minSize, size));\n                    }\n                    variableSize += child._getTempSize();\n                } else {\n                    child._setTempSize(prefSize);\n                }\n            }\n\n            totalSizeGiven += child._getTempSize();\n        }\n\n        // adjust sizes to exactly fit\n        if (variableSize > 0) {\n            while (totalSizeGiven < pixelSize) {\n                for (const child of drawChildren) {\n                    if (!(child instanceof SplitterNode)) {\n                        const prefSize = child._getPrefSize(this.getOrientation());\n                        if (!child._isFixed() && (prefSize === undefined || resizePreferred) && totalSizeGiven < pixelSize) {\n                            child._setTempSize(child._getTempSize() + 1);\n                            totalSizeGiven++;\n                        }\n                    }\n                }\n            }\n\n            // decrease size using nodes not at there minimum\n            while (totalSizeGiven > pixelSize) {\n                let changed = false;\n                for (const child of drawChildren) {\n                    if (!(child instanceof SplitterNode)) {\n                        const minSize = child.getMinSize(this.getOrientation());\n                        const size = child._getTempSize();\n                        if (size > minSize && totalSizeGiven > pixelSize) {\n                            child._setTempSize(child._getTempSize() - 1);\n                            totalSizeGiven--;\n                            changed = true;\n                        }\n                    }\n                }\n                if (!changed) {\n                    // all children are at min values\n                    break;\n                }\n            }\n\n            // if still too big then simply reduce all nodes until fits\n            while (totalSizeGiven > pixelSize) {\n                let changed = false;\n                for (const child of drawChildren) {\n                    if (!(child instanceof SplitterNode)) {\n                        const size = child._getTempSize();\n                        if (size > 0 && totalSizeGiven > pixelSize) {\n                            child._setTempSize(child._getTempSize() - 1);\n                            totalSizeGiven--;\n                            changed = true;\n                        }\n                    }\n                }\n                if (!changed) {\n                    // all children are at 0 values\n                    break;\n                }\n            }\n        }\n\n        // layout children\n        let p = 0;\n        for (const child of drawChildren) {\n            if (this.getOrientation() === Orientation.HORZ) {\n                child._layout(new Rect(this._rect.x + p, this._rect.y, child._getTempSize(), this._rect.height), metrics);\n            } else {\n                child._layout(new Rect(this._rect.x, this._rect.y + p, this._rect.width, child._getTempSize()), metrics);\n            }\n            p += child._getTempSize();\n        }\n\n        return true;\n    }\n\n    /** @internal */\n    _getSplitterBounds(splitterNode: SplitterNode, useMinSize: boolean = false) {\n        const pBounds = [0, 0];\n        const drawChildren = this._getDrawChildren() as (RowNode | TabSetNode | SplitterNode)[];\n        const p = drawChildren.indexOf(splitterNode);\n        const node1 = drawChildren[p - 1];\n        const node2 = drawChildren[p + 1];\n        if (this.getOrientation() === Orientation.HORZ) {\n            const minSize1 = useMinSize ? node1.getMinWidth() : 0;\n            const minSize2 = useMinSize ? node2.getMinWidth() : 0;\n            pBounds[0] = node1.getRect().x + minSize1;\n            pBounds[1] = node2.getRect().getRight() - splitterNode.getWidth() - minSize2;\n        } else {\n            const minSize1 = useMinSize ? node1.getMinHeight() : 0;\n            const minSize2 = useMinSize ? node2.getMinHeight() : 0;\n            pBounds[0] = node1.getRect().y + minSize1;\n            pBounds[1] = node2.getRect().getBottom() - splitterNode.getHeight() - minSize2;\n        }\n        return pBounds;\n    }\n\n    /** @internal */\n    _calculateSplit(splitter: SplitterNode, splitterPos: number) {\n        let rtn;\n        const drawChildren = this._getDrawChildren() as (RowNode | TabSetNode | SplitterNode)[];\n        const p = drawChildren.indexOf(splitter);\n        const pBounds = this._getSplitterBounds(splitter);\n\n        const weightedLength = drawChildren[p - 1].getWeight() + drawChildren[p + 1].getWeight();\n\n        const pixelWidth1 = Math.max(0, splitterPos - pBounds[0]);\n        const pixelWidth2 = Math.max(0, pBounds[1] - splitterPos);\n\n        if (pixelWidth1 + pixelWidth2 > 0) {\n            const weight1 = (pixelWidth1 * weightedLength) / (pixelWidth1 + pixelWidth2);\n            const weight2 = (pixelWidth2 * weightedLength) / (pixelWidth1 + pixelWidth2);\n\n            rtn = {\n                node1Id: drawChildren[p - 1].getId(),\n                weight1,\n                pixelWidth1,\n                node2Id: drawChildren[p + 1].getId(),\n                weight2,\n                pixelWidth2,\n            };\n        }\n\n        return rtn;\n    }\n\n    /** @internal */\n    _getDrawChildren(): Node[] | undefined {\n        if (this._dirty) {\n            this._drawChildren = [];\n\n            for (let i = 0; i < this._children.length; i++) {\n                const child = this._children[i] as RowNode | TabSetNode;\n                if (i !== 0) {\n                    const newSplitter = new SplitterNode(this._model);\n                    newSplitter._setParent(this);\n                    this._drawChildren.push(newSplitter);\n                }\n                this._drawChildren.push(child);\n            }\n            this._dirty = false;\n        }\n\n        return this._drawChildren;\n    }\n\n    /** @internal */\n    getMinSize(orientation: Orientation) {\n        if (orientation === Orientation.HORZ) {\n            return this.getMinWidth();\n        } else {\n            return this.getMinHeight();\n        }\n    }\n\n    /** @internal */\n    getMinWidth() {\n        return this._minWidth;\n    }\n\n    /** @internal */\n    getMinHeight() {\n        return this._minHeight;\n    }\n\n    /** @internal */\n    calcMinSize() {\n        this._minHeight = 0;\n        this._minWidth = 0;\n        let first = true;\n        for (const child of this._children) {\n            const c = child as RowNode | TabSetNode;\n            if (c instanceof RowNode) {\n                c.calcMinSize();\n            }\n            if (this.getOrientation() === Orientation.VERT) {\n                this._minHeight += c.getMinHeight();\n                if (!first) {\n                    this._minHeight += this._model.getSplitterSize();\n                }\n                this._minWidth = Math.max(this._minWidth, c.getMinWidth());\n            } else {\n                this._minWidth += c.getMinWidth();\n                if (!first) {\n                    this._minWidth += this._model.getSplitterSize();\n                }\n                this._minHeight = Math.max(this._minHeight, c.getMinHeight());\n            }\n            first = false;\n        }\n    }\n\n    /** @internal */\n    _tidy() {\n        let i = 0;\n        while (i < this._children.length) {\n            const child = this._children[i];\n            if (child instanceof RowNode) {\n                child._tidy();\n\n                const childChildren = child.getChildren();\n                if (childChildren.length === 0) {\n                    this._removeChild(child);\n                } else if (childChildren.length === 1) {\n                    // hoist child/children up to this level\n                    const subchild = childChildren[0];\n                    this._removeChild(child);\n                    if (subchild instanceof RowNode) {\n                        let subChildrenTotal = 0;\n                        const subChildChildren = subchild.getChildren();\n                        for (const ssc of subChildChildren) {\n                            const subsubChild = ssc as RowNode | TabSetNode;\n                            subChildrenTotal += subsubChild.getWeight();\n                        }\n                        for (let j = 0; j < subChildChildren.length; j++) {\n                            const subsubChild = subChildChildren[j] as RowNode | TabSetNode;\n                            subsubChild._setWeight((child.getWeight() * subsubChild.getWeight()) / subChildrenTotal);\n                            this._addChild(subsubChild, i + j);\n                        }\n                    } else {\n                        subchild._setWeight(child.getWeight());\n                        this._addChild(subchild, i);\n                    }\n                } else {\n                    i++;\n                }\n            } else if (child instanceof TabSetNode && child.getChildren().length === 0) {\n                if (child.isEnableDeleteWhenEmpty()) {\n                    this._removeChild(child);\n                    if (child === this._model.getMaximizedTabset()) {\n                        this._model._setMaximizedTabset(undefined);\n                    }\n                } else {\n                    i++;\n                }\n            } else {\n                i++;\n            }\n        }\n\n        // add tabset into empty root\n        if (this === this._model.getRoot() && this._children.length === 0) {\n            const callback = this._model._getOnCreateTabSet();\n            let attrs = callback ? callback() : {};\n            attrs = { ...attrs, selected: -1 };\n            const child = new TabSetNode(this._model, attrs);\n            this._model._setActiveTabset(child);\n            this._addChild(child);\n        }\n\n    }\n\n    /** @internal */\n    canDrop(dragNode: Node & IDraggable, x: number, y: number): DropInfo | undefined {\n        const yy = y - this._rect.y;\n        const xx = x - this._rect.x;\n        const w = this._rect.width;\n        const h = this._rect.height;\n        const margin = 10; // height of edge rect\n        const half = 50; // half width of edge rect\n        let dropInfo;\n\n        if (this._model.isEnableEdgeDock() && this._parent === undefined) {\n            // _root row\n            if (x < this._rect.x + margin && yy > h / 2 - half && yy < h / 2 + half) {\n                const dockLocation = DockLocation.LEFT;\n                const outlineRect = dockLocation.getDockRect(this._rect);\n                outlineRect.width = outlineRect.width / 2;\n                dropInfo = new DropInfo(this, outlineRect, dockLocation, -1, CLASSES.FLEXLAYOUT__OUTLINE_RECT_EDGE);\n            } else if (x > this._rect.getRight() - margin && yy > h / 2 - half && yy < h / 2 + half) {\n                const dockLocation = DockLocation.RIGHT;\n                const outlineRect = dockLocation.getDockRect(this._rect);\n                outlineRect.width = outlineRect.width / 2;\n                outlineRect.x += outlineRect.width;\n                dropInfo = new DropInfo(this, outlineRect, dockLocation, -1, CLASSES.FLEXLAYOUT__OUTLINE_RECT_EDGE);\n            } else if (y < this._rect.y + margin && xx > w / 2 - half && xx < w / 2 + half) {\n                const dockLocation = DockLocation.TOP;\n                const outlineRect = dockLocation.getDockRect(this._rect);\n                outlineRect.height = outlineRect.height / 2;\n                dropInfo = new DropInfo(this, outlineRect, dockLocation, -1, CLASSES.FLEXLAYOUT__OUTLINE_RECT_EDGE);\n            } else if (y > this._rect.getBottom() - margin && xx > w / 2 - half && xx < w / 2 + half) {\n                const dockLocation = DockLocation.BOTTOM;\n                const outlineRect = dockLocation.getDockRect(this._rect);\n                outlineRect.height = outlineRect.height / 2;\n                outlineRect.y += outlineRect.height;\n                dropInfo = new DropInfo(this, outlineRect, dockLocation, -1, CLASSES.FLEXLAYOUT__OUTLINE_RECT_EDGE);\n            }\n\n            if (dropInfo !== undefined) {\n                if (!dragNode._canDockInto(dragNode, dropInfo)) {\n                    return undefined;\n                }\n            }\n        }\n\n        return dropInfo;\n    }\n\n    /** @internal */\n    drop(dragNode: Node & IDraggable, location: DockLocation, index: number): void {\n        const dockLocation = location;\n\n        const parent = dragNode.getParent();\n\n        if (parent) {\n            parent._removeChild(dragNode);\n        }\n\n        if (parent !== undefined && parent!.getType() === TabSetNode.TYPE) {\n            parent._setSelected(0);\n        }\n\n        if (parent !== undefined && parent!.getType() === BorderNode.TYPE) {\n            parent._setSelected(-1);\n        }\n\n        let tabSet: TabSetNode | undefined;\n        if (dragNode instanceof TabSetNode) {\n            tabSet = dragNode;\n        } else {\n            const callback = this._model._getOnCreateTabSet();\n            tabSet = new TabSetNode(this._model, callback ? callback(dragNode as TabNode) : {});\n            tabSet._addChild(dragNode);\n        }\n        let size = this._children.reduce((sum, child) => {\n            return sum + (child as RowNode | TabSetNode).getWeight();\n        }, 0);\n\n        if (size === 0) {\n            size = 100;\n        }\n\n        tabSet._setWeight(size / 3);\n\n        const horz = !this._model.isRootOrientationVertical();\n\n        if (horz && dockLocation === DockLocation.LEFT || !horz && dockLocation === DockLocation.TOP) {\n            this._addChild(tabSet, 0);\n        } else if (horz && dockLocation === DockLocation.RIGHT || !horz && dockLocation === DockLocation.BOTTOM) {\n            this._addChild(tabSet);\n        } else if (horz && dockLocation === DockLocation.TOP || !horz && dockLocation === DockLocation.LEFT) {\n            const vrow = new RowNode(this._model, {});\n            const hrow = new RowNode(this._model, {});\n            hrow._setWeight(75);\n            tabSet._setWeight(25);\n            for (const child of this._children) {\n                hrow._addChild(child);\n            }\n            this._removeAll();\n            vrow._addChild(tabSet);\n            vrow._addChild(hrow);\n            this._addChild(vrow);\n        } else if (horz && dockLocation === DockLocation.BOTTOM || !horz && dockLocation === DockLocation.RIGHT) {\n            const vrow = new RowNode(this._model, {});\n            const hrow = new RowNode(this._model, {});\n            hrow._setWeight(75);\n            tabSet._setWeight(25);\n            for (const child of this._children) {\n                hrow._addChild(child);\n            }\n            this._removeAll();\n            vrow._addChild(hrow);\n            vrow._addChild(tabSet);\n            this._addChild(vrow);\n        }\n\n        this._model._setActiveTabset(tabSet);\n\n        this._model._tidy();\n    }\n\n    toJson(): IJsonRowNode {\n        const json: any = {};\n        RowNode._attributeDefinitions.toJson(json, this._attributes);\n\n        json.children = [];\n        for (const child of this._children) {\n            json.children.push(child.toJson());\n        }\n\n        return json;\n    }\n\n    isEnableDrop() {\n        return true;\n    }\n\n    /** @internal */\n    _getPrefSize(orientation: Orientation) {\n        let prefSize = this.getWidth();\n        if (orientation === Orientation.VERT) {\n            prefSize = this.getHeight();\n        }\n        return prefSize;\n    }\n\n    /** @internal */\n    _getAttributeDefinitions() {\n        return RowNode._attributeDefinitions;\n    }\n\n    /** @internal */\n    _updateAttrs(json: any) {\n        RowNode._attributeDefinitions.update(json, this._attributes);\n    }\n\n    /** @internal */\n    static getAttributeDefinitions() {\n        return RowNode._attributeDefinitions;\n    }\n\n}\n"]},"metadata":{},"sourceType":"script"}