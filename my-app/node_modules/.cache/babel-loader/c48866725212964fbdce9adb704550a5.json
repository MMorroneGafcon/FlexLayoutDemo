{"ast":null,"code":"\"use strict\";\n\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Model = void 0;\n\nvar uuid_1 = require(\"uuid\");\n\nvar Attribute_1 = require(\"../Attribute\");\n\nvar AttributeDefinitions_1 = require(\"../AttributeDefinitions\");\n\nvar DockLocation_1 = require(\"../DockLocation\");\n\nvar Orientation_1 = require(\"../Orientation\");\n\nvar Rect_1 = require(\"../Rect\");\n\nvar Actions_1 = require(\"./Actions\");\n\nvar BorderNode_1 = require(\"./BorderNode\");\n\nvar BorderSet_1 = require(\"./BorderSet\");\n\nvar RowNode_1 = require(\"./RowNode\");\n\nvar TabNode_1 = require(\"./TabNode\");\n\nvar TabSetNode_1 = require(\"./TabSetNode\");\n\nvar Utils_1 = require(\"./Utils\");\n/**\n * Class containing the Tree of Nodes used by the FlexLayout component\n */\n\n\nvar Model =\n/** @class */\nfunction () {\n  /**\n   * 'private' constructor. Use the static method Model.fromJson(json) to create a model\n   *  @internal\n   */\n  function Model() {\n    /** @internal */\n    this._borderRects = {\n      inner: Rect_1.Rect.empty(),\n      outer: Rect_1.Rect.empty()\n    };\n    this._attributes = {};\n    this._idMap = {};\n    this._borders = new BorderSet_1.BorderSet(this);\n    this._pointerFine = true;\n    this._showHiddenBorder = DockLocation_1.DockLocation.CENTER;\n  }\n  /**\n   * Loads the model from the given json object\n   * @param json the json model to load\n   * @returns {Model} a new Model object\n   */\n\n\n  Model.fromJson = function (json) {\n    var model = new Model();\n\n    Model._attributeDefinitions.fromJson(json.global, model._attributes);\n\n    if (json.borders) {\n      model._borders = BorderSet_1.BorderSet._fromJson(json.borders, model);\n    }\n\n    model._root = RowNode_1.RowNode._fromJson(json.layout, model);\n\n    model._tidy(); // initial tidy of node tree\n\n\n    return model;\n  };\n  /** @internal */\n\n\n  Model._createAttributeDefinitions = function () {\n    var attributeDefinitions = new AttributeDefinitions_1.AttributeDefinitions();\n    attributeDefinitions.add(\"legacyOverflowMenu\", false).setType(Attribute_1.Attribute.BOOLEAN); // splitter\n\n    attributeDefinitions.add(\"splitterSize\", -1).setType(Attribute_1.Attribute.NUMBER);\n    attributeDefinitions.add(\"splitterExtra\", 0).setType(Attribute_1.Attribute.NUMBER);\n    attributeDefinitions.add(\"enableEdgeDock\", true).setType(Attribute_1.Attribute.BOOLEAN);\n    attributeDefinitions.add(\"rootOrientationVertical\", false).setType(Attribute_1.Attribute.BOOLEAN);\n    attributeDefinitions.add(\"marginInsets\", {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    }).setType(\"IInsets\");\n    attributeDefinitions.add(\"enableUseVisibility\", false).setType(Attribute_1.Attribute.BOOLEAN); // tab\n\n    attributeDefinitions.add(\"tabEnableClose\", true).setType(Attribute_1.Attribute.BOOLEAN);\n    attributeDefinitions.add(\"tabCloseType\", 1).setType(\"ICloseType\");\n    attributeDefinitions.add(\"tabEnableFloat\", false).setType(Attribute_1.Attribute.BOOLEAN);\n    attributeDefinitions.add(\"tabEnableDrag\", true).setType(Attribute_1.Attribute.BOOLEAN);\n    attributeDefinitions.add(\"tabEnableRename\", true).setType(Attribute_1.Attribute.BOOLEAN);\n    attributeDefinitions.add(\"tabClassName\", undefined).setType(Attribute_1.Attribute.STRING);\n    attributeDefinitions.add(\"tabIcon\", undefined).setType(Attribute_1.Attribute.STRING);\n    attributeDefinitions.add(\"tabEnableRenderOnDemand\", true).setType(Attribute_1.Attribute.BOOLEAN);\n    attributeDefinitions.add(\"tabDragSpeed\", 0.3).setType(Attribute_1.Attribute.NUMBER);\n    attributeDefinitions.add(\"tabBorderWidth\", -1).setType(Attribute_1.Attribute.NUMBER);\n    attributeDefinitions.add(\"tabBorderHeight\", -1).setType(Attribute_1.Attribute.NUMBER); // tabset\n\n    attributeDefinitions.add(\"tabSetEnableDeleteWhenEmpty\", true).setType(Attribute_1.Attribute.BOOLEAN);\n    attributeDefinitions.add(\"tabSetEnableDrop\", true).setType(Attribute_1.Attribute.BOOLEAN);\n    attributeDefinitions.add(\"tabSetEnableDrag\", true).setType(Attribute_1.Attribute.BOOLEAN);\n    attributeDefinitions.add(\"tabSetEnableDivide\", true).setType(Attribute_1.Attribute.BOOLEAN);\n    attributeDefinitions.add(\"tabSetEnableMaximize\", true).setType(Attribute_1.Attribute.BOOLEAN);\n    attributeDefinitions.add(\"tabSetEnableClose\", false).setType(Attribute_1.Attribute.BOOLEAN);\n    attributeDefinitions.add(\"tabSetAutoSelectTab\", true).setType(Attribute_1.Attribute.BOOLEAN);\n    attributeDefinitions.add(\"tabSetClassNameTabStrip\", undefined).setType(Attribute_1.Attribute.STRING);\n    attributeDefinitions.add(\"tabSetClassNameHeader\", undefined).setType(Attribute_1.Attribute.STRING);\n    attributeDefinitions.add(\"tabSetEnableTabStrip\", true).setType(Attribute_1.Attribute.BOOLEAN);\n    attributeDefinitions.add(\"tabSetHeaderHeight\", 0).setType(Attribute_1.Attribute.NUMBER);\n    attributeDefinitions.add(\"tabSetTabStripHeight\", 0).setType(Attribute_1.Attribute.NUMBER);\n    attributeDefinitions.add(\"tabSetMarginInsets\", {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    }).setType(\"IInsets\");\n    attributeDefinitions.add(\"tabSetBorderInsets\", {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    }).setType(\"IInsets\");\n    attributeDefinitions.add(\"tabSetTabLocation\", \"top\").setType(\"ITabLocation\");\n    attributeDefinitions.add(\"tabSetMinWidth\", 0).setType(Attribute_1.Attribute.NUMBER);\n    attributeDefinitions.add(\"tabSetMinHeight\", 0).setType(Attribute_1.Attribute.NUMBER); // border\n\n    attributeDefinitions.add(\"borderSize\", 200).setType(Attribute_1.Attribute.NUMBER);\n    attributeDefinitions.add(\"borderMinSize\", 0).setType(Attribute_1.Attribute.NUMBER);\n    attributeDefinitions.add(\"borderBarSize\", 0).setType(Attribute_1.Attribute.NUMBER);\n    attributeDefinitions.add(\"borderEnableDrop\", true).setType(Attribute_1.Attribute.BOOLEAN);\n    attributeDefinitions.add(\"borderAutoSelectTabWhenOpen\", true).setType(Attribute_1.Attribute.BOOLEAN);\n    attributeDefinitions.add(\"borderAutoSelectTabWhenClosed\", false).setType(Attribute_1.Attribute.BOOLEAN);\n    attributeDefinitions.add(\"borderClassName\", undefined).setType(Attribute_1.Attribute.STRING);\n    attributeDefinitions.add(\"borderEnableAutoHide\", false).setType(Attribute_1.Attribute.BOOLEAN);\n    return attributeDefinitions;\n  };\n  /** @internal */\n\n\n  Model.prototype._setChangeListener = function (listener) {\n    this._changeListener = listener;\n  };\n  /**\n   * Get the currently active tabset node\n   */\n\n\n  Model.prototype.getActiveTabset = function () {\n    if (this._activeTabSet && this.getNodeById(this._activeTabSet.getId())) {\n      return this._activeTabSet;\n    } else {\n      return undefined;\n    }\n  };\n  /** @internal */\n\n\n  Model.prototype._getShowHiddenBorder = function () {\n    return this._showHiddenBorder;\n  };\n  /** @internal */\n\n\n  Model.prototype._setShowHiddenBorder = function (location) {\n    this._showHiddenBorder = location;\n  };\n  /** @internal */\n\n\n  Model.prototype._setActiveTabset = function (tabsetNode) {\n    this._activeTabSet = tabsetNode;\n  };\n  /**\n   * Get the currently maximized tabset node\n   */\n\n\n  Model.prototype.getMaximizedTabset = function () {\n    return this._maximizedTabSet;\n  };\n  /** @internal */\n\n\n  Model.prototype._setMaximizedTabset = function (tabsetNode) {\n    this._maximizedTabSet = tabsetNode;\n  };\n  /**\n   * Gets the root RowNode of the model\n   * @returns {RowNode}\n   */\n\n\n  Model.prototype.getRoot = function () {\n    return this._root;\n  };\n\n  Model.prototype.isRootOrientationVertical = function () {\n    return this._attributes.rootOrientationVertical;\n  };\n\n  Model.prototype.isUseVisibility = function () {\n    return this._attributes.enableUseVisibility;\n  };\n  /**\n   * Gets the\n   * @returns {BorderSet|*}\n   */\n\n\n  Model.prototype.getBorderSet = function () {\n    return this._borders;\n  };\n  /** @internal */\n\n\n  Model.prototype._getOuterInnerRects = function () {\n    return this._borderRects;\n  };\n  /** @internal */\n\n\n  Model.prototype._getPointerFine = function () {\n    return this._pointerFine;\n  };\n  /** @internal */\n\n\n  Model.prototype._setPointerFine = function (pointerFine) {\n    this._pointerFine = pointerFine;\n  };\n  /**\n   * Visits all the nodes in the model and calls the given function for each\n   * @param fn a function that takes visited node and a integer level as parameters\n   */\n\n\n  Model.prototype.visitNodes = function (fn) {\n    this._borders._forEachNode(fn);\n\n    this._root._forEachNode(fn, 0);\n  };\n  /**\n   * Gets a node by its id\n   * @param id the id to find\n   */\n\n\n  Model.prototype.getNodeById = function (id) {\n    return this._idMap[id];\n  };\n  /**\n   * Update the node tree by performing the given action,\n   * Actions should be generated via static methods on the Actions class\n   * @param action the action to perform\n   * @returns added Node for Actions.addNode; undefined otherwise\n   */\n\n\n  Model.prototype.doAction = function (action) {\n    var returnVal = undefined; // console.log(action);\n\n    switch (action.type) {\n      case Actions_1.Actions.ADD_NODE:\n        {\n          var newNode = new TabNode_1.TabNode(this, action.data.json, true);\n          var toNode = this._idMap[action.data.toNode];\n\n          if (toNode instanceof TabSetNode_1.TabSetNode || toNode instanceof BorderNode_1.BorderNode || toNode instanceof RowNode_1.RowNode) {\n            toNode.drop(newNode, DockLocation_1.DockLocation.getByName(action.data.location), action.data.index, action.data.select);\n            returnVal = newNode;\n          }\n\n          break;\n        }\n\n      case Actions_1.Actions.MOVE_NODE:\n        {\n          var fromNode = this._idMap[action.data.fromNode];\n\n          if (fromNode instanceof TabNode_1.TabNode || fromNode instanceof TabSetNode_1.TabSetNode) {\n            var toNode = this._idMap[action.data.toNode];\n\n            if (toNode instanceof TabSetNode_1.TabSetNode || toNode instanceof BorderNode_1.BorderNode || toNode instanceof RowNode_1.RowNode) {\n              toNode.drop(fromNode, DockLocation_1.DockLocation.getByName(action.data.location), action.data.index, action.data.select);\n            }\n          }\n\n          break;\n        }\n\n      case Actions_1.Actions.DELETE_TAB:\n        {\n          var node = this._idMap[action.data.node];\n\n          if (node instanceof TabNode_1.TabNode) {\n            node._delete();\n          }\n\n          break;\n        }\n\n      case Actions_1.Actions.DELETE_TABSET:\n        {\n          var node = this._idMap[action.data.node];\n\n          if (node instanceof TabSetNode_1.TabSetNode) {\n            // first delete all child tabs that are closeable\n            var children = __spreadArray([], node.getChildren(), true);\n\n            for (var i = 0; i < children.length; i++) {\n              var child = children[i];\n\n              if (child.isEnableClose()) {\n                child._delete();\n              }\n            }\n\n            if (node.getChildren().length === 0) {\n              node._delete();\n            }\n\n            this._tidy();\n          }\n\n          break;\n        }\n\n      case Actions_1.Actions.FLOAT_TAB:\n        {\n          var node = this._idMap[action.data.node];\n\n          if (node instanceof TabNode_1.TabNode) {\n            node._setFloating(true);\n\n            (0, Utils_1.adjustSelectedIndexAfterFloat)(node);\n          }\n\n          break;\n        }\n\n      case Actions_1.Actions.UNFLOAT_TAB:\n        {\n          var node = this._idMap[action.data.node];\n\n          if (node instanceof TabNode_1.TabNode) {\n            node._setFloating(false);\n\n            (0, Utils_1.adjustSelectedIndexAfterDock)(node);\n          }\n\n          break;\n        }\n\n      case Actions_1.Actions.RENAME_TAB:\n        {\n          var node = this._idMap[action.data.node];\n\n          if (node instanceof TabNode_1.TabNode) {\n            node._setName(action.data.text);\n          }\n\n          break;\n        }\n\n      case Actions_1.Actions.SELECT_TAB:\n        {\n          var tabNode = this._idMap[action.data.tabNode];\n\n          if (tabNode instanceof TabNode_1.TabNode) {\n            var parent_1 = tabNode.getParent();\n            var pos = parent_1.getChildren().indexOf(tabNode);\n\n            if (parent_1 instanceof BorderNode_1.BorderNode) {\n              if (parent_1.getSelected() === pos) {\n                parent_1._setSelected(-1);\n              } else {\n                parent_1._setSelected(pos);\n              }\n            } else if (parent_1 instanceof TabSetNode_1.TabSetNode) {\n              if (parent_1.getSelected() !== pos) {\n                parent_1._setSelected(pos);\n              }\n\n              this._activeTabSet = parent_1;\n            }\n          }\n\n          break;\n        }\n\n      case Actions_1.Actions.SET_ACTIVE_TABSET:\n        {\n          var tabsetNode = this._idMap[action.data.tabsetNode];\n\n          if (tabsetNode instanceof TabSetNode_1.TabSetNode) {\n            this._activeTabSet = tabsetNode;\n          }\n\n          break;\n        }\n\n      case Actions_1.Actions.ADJUST_SPLIT:\n        {\n          var node1 = this._idMap[action.data.node1];\n          var node2 = this._idMap[action.data.node2];\n\n          if ((node1 instanceof TabSetNode_1.TabSetNode || node1 instanceof RowNode_1.RowNode) && (node2 instanceof TabSetNode_1.TabSetNode || node2 instanceof RowNode_1.RowNode)) {\n            this._adjustSplitSide(node1, action.data.weight1, action.data.pixelWidth1);\n\n            this._adjustSplitSide(node2, action.data.weight2, action.data.pixelWidth2);\n          }\n\n          break;\n        }\n\n      case Actions_1.Actions.ADJUST_BORDER_SPLIT:\n        {\n          var node = this._idMap[action.data.node];\n\n          if (node instanceof BorderNode_1.BorderNode) {\n            node._setSize(action.data.pos);\n          }\n\n          break;\n        }\n\n      case Actions_1.Actions.MAXIMIZE_TOGGLE:\n        {\n          var node = this._idMap[action.data.node];\n\n          if (node instanceof TabSetNode_1.TabSetNode) {\n            if (node === this._maximizedTabSet) {\n              this._maximizedTabSet = undefined;\n            } else {\n              this._maximizedTabSet = node;\n              this._activeTabSet = node;\n            }\n          }\n\n          break;\n        }\n\n      case Actions_1.Actions.UPDATE_MODEL_ATTRIBUTES:\n        {\n          this._updateAttrs(action.data.json);\n\n          break;\n        }\n\n      case Actions_1.Actions.UPDATE_NODE_ATTRIBUTES:\n        {\n          var node = this._idMap[action.data.node];\n\n          node._updateAttrs(action.data.json);\n\n          break;\n        }\n\n      default:\n        break;\n    }\n\n    this._updateIdMap();\n\n    if (this._changeListener !== undefined) {\n      this._changeListener();\n    }\n\n    return returnVal;\n  };\n  /** @internal */\n\n\n  Model.prototype._updateIdMap = function () {\n    var _this = this; // regenerate idMap to stop it building up\n\n\n    this._idMap = {};\n    this.visitNodes(function (node) {\n      return _this._idMap[node.getId()] = node;\n    }); // console.log(JSON.stringify(Object.keys(this._idMap)));\n  };\n  /** @internal */\n\n\n  Model.prototype._adjustSplitSide = function (node, weight, pixels) {\n    node._setWeight(weight);\n\n    if (node.getWidth() != null && node.getOrientation() === Orientation_1.Orientation.VERT) {\n      node._updateAttrs({\n        width: pixels\n      });\n    } else if (node.getHeight() != null && node.getOrientation() === Orientation_1.Orientation.HORZ) {\n      node._updateAttrs({\n        height: pixels\n      });\n    }\n  };\n  /**\n   * Converts the model to a json object\n   * @returns {IJsonModel} json object that represents this model\n   */\n\n\n  Model.prototype.toJson = function () {\n    var global = {};\n\n    Model._attributeDefinitions.toJson(global, this._attributes); // save state of nodes\n\n\n    this.visitNodes(function (node) {\n      node._fireEvent(\"save\", undefined);\n    });\n    return {\n      global: global,\n      borders: this._borders._toJson(),\n      layout: this._root.toJson()\n    };\n  };\n\n  Model.prototype.getSplitterSize = function () {\n    var splitterSize = this._attributes.splitterSize;\n\n    if (splitterSize === -1) {\n      // use defaults\n      splitterSize = this._pointerFine ? 8 : 12; // larger for mobile\n    }\n\n    return splitterSize;\n  };\n\n  Model.prototype.isLegacyOverflowMenu = function () {\n    return this._attributes.legacyOverflowMenu;\n  };\n\n  Model.prototype.getSplitterExtra = function () {\n    return this._attributes.splitterExtra;\n  };\n\n  Model.prototype.isEnableEdgeDock = function () {\n    return this._attributes.enableEdgeDock;\n  };\n  /** @internal */\n\n\n  Model.prototype._addNode = function (node) {\n    var id = node.getId();\n\n    if (this._idMap[id] !== undefined) {\n      throw new Error(\"Error: each node must have a unique id, duplicate id:\".concat(node.getId()));\n    }\n\n    if (node.getType() !== \"splitter\") {\n      this._idMap[id] = node;\n    }\n  };\n  /** @internal */\n\n\n  Model.prototype._layout = function (rect, metrics) {\n    var _a; // let start = Date.now();\n\n\n    this._borderRects = this._borders._layoutBorder({\n      outer: rect,\n      inner: rect\n    }, metrics);\n    rect = this._borderRects.inner.removeInsets(this._getAttribute(\"marginInsets\"));\n    (_a = this._root) === null || _a === void 0 ? void 0 : _a.calcMinSize();\n\n    this._root._layout(rect, metrics); // console.log(\"layout time: \" + (Date.now() - start));\n\n\n    return rect;\n  };\n  /** @internal */\n\n\n  Model.prototype._findDropTargetNode = function (dragNode, x, y) {\n    var node = this._root._findDropTargetNode(dragNode, x, y);\n\n    if (node === undefined) {\n      node = this._borders._findDropTargetNode(dragNode, x, y);\n    }\n\n    return node;\n  };\n  /** @internal */\n\n\n  Model.prototype._tidy = function () {\n    // console.log(\"before _tidy\", this.toString());\n    this._root._tidy(); // console.log(\"after _tidy\", this.toString());\n\n  };\n  /** @internal */\n\n\n  Model.prototype._updateAttrs = function (json) {\n    Model._attributeDefinitions.update(json, this._attributes);\n  };\n  /** @internal */\n\n\n  Model.prototype._nextUniqueId = function () {\n    return '#' + (0, uuid_1.v4)();\n  };\n  /** @internal */\n\n\n  Model.prototype._getAttribute = function (name) {\n    return this._attributes[name];\n  };\n  /**\n   * Sets a function to allow/deny dropping a node\n   * @param onAllowDrop function that takes the drag node and DropInfo and returns true if the drop is allowed\n   */\n\n\n  Model.prototype.setOnAllowDrop = function (onAllowDrop) {\n    this._onAllowDrop = onAllowDrop;\n  };\n  /** @internal */\n\n\n  Model.prototype._getOnAllowDrop = function () {\n    return this._onAllowDrop;\n  };\n  /**\n   * set callback called when a new TabSet is created.\n   * The tabNode can be undefined if it's the auto created first tabset in the root row (when the last\n   * tab is deleted, the root tabset can be recreated)\n   * @param onCreateTabSet\n   */\n\n\n  Model.prototype.setOnCreateTabSet = function (onCreateTabSet) {\n    this._onCreateTabSet = onCreateTabSet;\n  };\n  /** @internal */\n\n\n  Model.prototype._getOnCreateTabSet = function () {\n    return this._onCreateTabSet;\n  };\n\n  Model.toTypescriptInterfaces = function () {\n    console.log(Model._attributeDefinitions.toTypescriptInterface(\"Global\", undefined));\n    console.log(RowNode_1.RowNode.getAttributeDefinitions().toTypescriptInterface(\"Row\", Model._attributeDefinitions));\n    console.log(TabSetNode_1.TabSetNode.getAttributeDefinitions().toTypescriptInterface(\"TabSet\", Model._attributeDefinitions));\n    console.log(TabNode_1.TabNode.getAttributeDefinitions().toTypescriptInterface(\"Tab\", Model._attributeDefinitions));\n    console.log(BorderNode_1.BorderNode.getAttributeDefinitions().toTypescriptInterface(\"Border\", Model._attributeDefinitions));\n  };\n\n  Model.prototype.toString = function () {\n    return JSON.stringify(this.toJson());\n  };\n  /** @internal */\n\n\n  Model._attributeDefinitions = Model._createAttributeDefinitions();\n  return Model;\n}();\n\nexports.Model = Model;","map":{"version":3,"mappings":"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","names":["inner","Rect_1","empty","outer","_attributes","_idMap","_borders","BorderSet_1","_pointerFine","_showHiddenBorder","DockLocation_1","CENTER","Model","json","model","_attributeDefinitions","fromJson","global","borders","_fromJson","_root","RowNode_1","layout","_tidy","attributeDefinitions","AttributeDefinitions_1","add","setType","Attribute_1","BOOLEAN","NUMBER","top","right","bottom","left","undefined","STRING","listener","_changeListener","_activeTabSet","getNodeById","getId","location","tabsetNode","_maximizedTabSet","rootOrientationVertical","enableUseVisibility","_borderRects","pointerFine","fn","_forEachNode","id","action","returnVal","type","Actions_1","ADD_NODE","newNode","TabNode_1","data","toNode","TabSetNode_1","BorderNode_1","drop","getByName","index","select","MOVE_NODE","fromNode","DELETE_TAB","node","_delete","DELETE_TABSET","children","getChildren","i","length","child","isEnableClose","FLOAT_TAB","_setFloating","UNFLOAT_TAB","RENAME_TAB","_setName","text","SELECT_TAB","tabNode","parent_1","getParent","pos","indexOf","getSelected","_setSelected","SET_ACTIVE_TABSET","ADJUST_SPLIT","node1","node2","_adjustSplitSide","weight1","pixelWidth1","weight2","pixelWidth2","ADJUST_BORDER_SPLIT","_setSize","MAXIMIZE_TOGGLE","UPDATE_MODEL_ATTRIBUTES","_updateAttrs","UPDATE_NODE_ATTRIBUTES","_updateIdMap","visitNodes","_this","weight","pixels","_setWeight","getWidth","getOrientation","Orientation_1","VERT","width","getHeight","HORZ","height","toJson","_fireEvent","_toJson","splitterSize","legacyOverflowMenu","splitterExtra","enableEdgeDock","Error","getType","rect","metrics","_layoutBorder","removeInsets","_getAttribute","_a","calcMinSize","_layout","dragNode","x","y","_findDropTargetNode","update","name","onAllowDrop","_onAllowDrop","onCreateTabSet","_onCreateTabSet","console","log","toTypescriptInterface","getAttributeDefinitions","JSON","stringify","_createAttributeDefinitions","exports"],"sources":["C:\\Users\\mmorrone\\UnityProjects\\my-app\\node_modules\\flexlayout-react\\src\\model\\Model.ts"],"sourcesContent":["import { v4 as getUUID } from \"uuid\";\nimport { Attribute } from \"../Attribute\";\nimport { AttributeDefinitions } from \"../AttributeDefinitions\";\nimport { DockLocation } from \"../DockLocation\";\nimport { DropInfo } from \"../DropInfo\";\nimport { Orientation } from \"../Orientation\";\nimport { Rect } from \"../Rect\";\nimport { Action } from \"./Action\";\nimport { Actions } from \"./Actions\";\nimport { BorderNode } from \"./BorderNode\";\nimport { BorderSet } from \"./BorderSet\";\nimport { IDraggable } from \"./IDraggable\";\nimport { IDropTarget } from \"./IDropTarget\";\nimport { IJsonModel, ITabSetAttributes } from \"./IJsonModel\";\nimport { Node } from \"./Node\";\nimport { RowNode } from \"./RowNode\";\nimport { TabNode } from \"./TabNode\";\nimport { TabSetNode } from \"./TabSetNode\";\nimport { adjustSelectedIndexAfterDock, adjustSelectedIndexAfterFloat } from \"./Utils\";\n\n/** @internal */\nexport interface ILayoutMetrics {\n    headerBarSize: number;\n    tabBarSize: number;\n    borderBarSize: number;\n}\n\n/**\n * Class containing the Tree of Nodes used by the FlexLayout component\n */\nexport class Model {\n    /**\n     * Loads the model from the given json object\n     * @param json the json model to load\n     * @returns {Model} a new Model object\n     */\n    static fromJson(json: IJsonModel) {\n        const model = new Model();\n        Model._attributeDefinitions.fromJson(json.global, model._attributes);\n\n        if (json.borders) {\n            model._borders = BorderSet._fromJson(json.borders, model);\n        }\n        model._root = RowNode._fromJson(json.layout, model);\n        model._tidy(); // initial tidy of node tree\n        return model;\n    }\n    /** @internal */\n    private static _attributeDefinitions: AttributeDefinitions = Model._createAttributeDefinitions();\n\n    /** @internal */\n    private static _createAttributeDefinitions(): AttributeDefinitions {\n        const attributeDefinitions = new AttributeDefinitions();\n\n        attributeDefinitions.add(\"legacyOverflowMenu\", false).setType(Attribute.BOOLEAN);\n\n        // splitter\n        attributeDefinitions.add(\"splitterSize\", -1).setType(Attribute.NUMBER);\n        attributeDefinitions.add(\"splitterExtra\", 0).setType(Attribute.NUMBER);\n        attributeDefinitions.add(\"enableEdgeDock\", true).setType(Attribute.BOOLEAN);\n        attributeDefinitions.add(\"rootOrientationVertical\", false).setType(Attribute.BOOLEAN);\n        attributeDefinitions.add(\"marginInsets\", { top: 0, right: 0, bottom: 0, left: 0 })\n            .setType(\"IInsets\");\n        attributeDefinitions.add(\"enableUseVisibility\", false).setType(Attribute.BOOLEAN);\n\n        // tab\n        attributeDefinitions.add(\"tabEnableClose\", true).setType(Attribute.BOOLEAN);\n        attributeDefinitions.add(\"tabCloseType\", 1).setType(\"ICloseType\");\n        attributeDefinitions.add(\"tabEnableFloat\", false).setType(Attribute.BOOLEAN);\n        attributeDefinitions.add(\"tabEnableDrag\", true).setType(Attribute.BOOLEAN);\n        attributeDefinitions.add(\"tabEnableRename\", true).setType(Attribute.BOOLEAN);\n        attributeDefinitions.add(\"tabClassName\", undefined).setType(Attribute.STRING);\n        attributeDefinitions.add(\"tabIcon\", undefined).setType(Attribute.STRING);\n        attributeDefinitions.add(\"tabEnableRenderOnDemand\", true).setType(Attribute.BOOLEAN);\n        attributeDefinitions.add(\"tabDragSpeed\", 0.3).setType(Attribute.NUMBER);\n        attributeDefinitions.add(\"tabBorderWidth\", -1).setType(Attribute.NUMBER);\n        attributeDefinitions.add(\"tabBorderHeight\", -1).setType(Attribute.NUMBER);\n\n        // tabset\n        attributeDefinitions.add(\"tabSetEnableDeleteWhenEmpty\", true).setType(Attribute.BOOLEAN);\n        attributeDefinitions.add(\"tabSetEnableDrop\", true).setType(Attribute.BOOLEAN);\n        attributeDefinitions.add(\"tabSetEnableDrag\", true).setType(Attribute.BOOLEAN);\n        attributeDefinitions.add(\"tabSetEnableDivide\", true).setType(Attribute.BOOLEAN);\n        attributeDefinitions.add(\"tabSetEnableMaximize\", true).setType(Attribute.BOOLEAN);\n        attributeDefinitions.add(\"tabSetEnableClose\", false).setType(Attribute.BOOLEAN);\n        attributeDefinitions.add(\"tabSetAutoSelectTab\", true).setType(Attribute.BOOLEAN);\n        attributeDefinitions.add(\"tabSetClassNameTabStrip\", undefined).setType(Attribute.STRING);\n        attributeDefinitions.add(\"tabSetClassNameHeader\", undefined).setType(Attribute.STRING);\n        attributeDefinitions.add(\"tabSetEnableTabStrip\", true).setType(Attribute.BOOLEAN);\n        attributeDefinitions.add(\"tabSetHeaderHeight\", 0).setType(Attribute.NUMBER);\n        attributeDefinitions.add(\"tabSetTabStripHeight\", 0).setType(Attribute.NUMBER);\n        attributeDefinitions.add(\"tabSetMarginInsets\", { top: 0, right: 0, bottom: 0, left: 0 })\n            .setType(\"IInsets\");\n        attributeDefinitions.add(\"tabSetBorderInsets\", { top: 0, right: 0, bottom: 0, left: 0 })\n            .setType(\"IInsets\");\n        attributeDefinitions.add(\"tabSetTabLocation\", \"top\").setType(\"ITabLocation\");\n        attributeDefinitions.add(\"tabSetMinWidth\", 0).setType(Attribute.NUMBER);\n        attributeDefinitions.add(\"tabSetMinHeight\", 0).setType(Attribute.NUMBER);\n\n        // border\n        attributeDefinitions.add(\"borderSize\", 200).setType(Attribute.NUMBER);\n        attributeDefinitions.add(\"borderMinSize\", 0).setType(Attribute.NUMBER);\n        attributeDefinitions.add(\"borderBarSize\", 0).setType(Attribute.NUMBER);\n        attributeDefinitions.add(\"borderEnableDrop\", true).setType(Attribute.BOOLEAN);\n        attributeDefinitions.add(\"borderAutoSelectTabWhenOpen\", true).setType(Attribute.BOOLEAN);\n        attributeDefinitions.add(\"borderAutoSelectTabWhenClosed\", false).setType(Attribute.BOOLEAN);\n        attributeDefinitions.add(\"borderClassName\", undefined).setType(Attribute.STRING);\n        attributeDefinitions.add(\"borderEnableAutoHide\", false).setType(Attribute.BOOLEAN);\n\n        return attributeDefinitions;\n    }\n\n    /** @internal */\n    private _attributes: Record<string, any>;\n    /** @internal */\n    private _idMap: Record<string, Node>;\n    /** @internal */\n    private _changeListener?: () => void;\n    /** @internal */\n    private _root?: RowNode;\n    /** @internal */\n    private _borders: BorderSet;\n    /** @internal */\n    private _onAllowDrop?: (dragNode: Node, dropInfo: DropInfo) => boolean;\n    /** @internal */\n    private _maximizedTabSet?: TabSetNode;\n    /** @internal */\n    private _activeTabSet?: TabSetNode;\n    /** @internal */\n    private _borderRects: { inner: Rect; outer: Rect } = { inner: Rect.empty(), outer: Rect.empty() };\n    /** @internal */\n    private _pointerFine: boolean;\n    /** @internal */\n    private _onCreateTabSet?: (tabNode?: TabNode) => ITabSetAttributes;\n    /** @internal */\n    private _showHiddenBorder: DockLocation;\n\n\n    /**\n     * 'private' constructor. Use the static method Model.fromJson(json) to create a model\n     *  @internal\n     */\n\n    private constructor() {\n        this._attributes = {};\n        this._idMap = {};\n        this._borders = new BorderSet(this);\n        this._pointerFine = true;\n        this._showHiddenBorder = DockLocation.CENTER;\n    }\n\n    /** @internal */\n    _setChangeListener(listener: (() => void) | undefined) {\n        this._changeListener = listener;\n    }\n\n    /**\n     * Get the currently active tabset node\n     */\n    getActiveTabset() {\n        if (this._activeTabSet && this.getNodeById(this._activeTabSet.getId())) {\n            return this._activeTabSet;\n        } else {\n            return undefined;\n        }\n    }\n\n    /** @internal */\n    _getShowHiddenBorder() {\n        return this._showHiddenBorder;\n    }\n\n    /** @internal */\n    _setShowHiddenBorder(location: DockLocation) {\n        this._showHiddenBorder = location;\n    }\n\n    /** @internal */\n    _setActiveTabset(tabsetNode: TabSetNode | undefined) {\n        this._activeTabSet = tabsetNode;\n    }\n\n    /**\n     * Get the currently maximized tabset node\n     */\n    getMaximizedTabset() {\n        return this._maximizedTabSet;\n    }\n\n    /** @internal */\n    _setMaximizedTabset(tabsetNode: (TabSetNode | undefined)) {\n        this._maximizedTabSet = tabsetNode;\n    }\n\n    /**\n     * Gets the root RowNode of the model\n     * @returns {RowNode}\n     */\n    getRoot() {\n        return this._root as RowNode;\n    }\n\n    isRootOrientationVertical() {\n        return this._attributes.rootOrientationVertical as boolean;\n    }\n\n    isUseVisibility() {\n        return this._attributes.enableUseVisibility as boolean;\n    }\n\n    /**\n     * Gets the\n     * @returns {BorderSet|*}\n     */\n    getBorderSet() {\n        return this._borders;\n    }\n\n    /** @internal */\n    _getOuterInnerRects() {\n        return this._borderRects;\n    }\n\n    /** @internal */\n    _getPointerFine() {\n        return this._pointerFine;\n    }\n\n    /** @internal */\n    _setPointerFine(pointerFine: boolean) {\n        this._pointerFine = pointerFine;\n    }\n\n    /**\n     * Visits all the nodes in the model and calls the given function for each\n     * @param fn a function that takes visited node and a integer level as parameters\n     */\n    visitNodes(fn: (node: Node, level: number) => void) {\n        this._borders._forEachNode(fn);\n        (this._root as RowNode)._forEachNode(fn, 0);\n    }\n\n    /**\n     * Gets a node by its id\n     * @param id the id to find\n     */\n    getNodeById(id: string) {\n        return this._idMap[id];\n    }\n\n    /**\n     * Update the node tree by performing the given action,\n     * Actions should be generated via static methods on the Actions class\n     * @param action the action to perform\n     * @returns added Node for Actions.addNode; undefined otherwise\n     */\n    doAction(action: Action): Node | undefined {\n        let returnVal = undefined;\n        // console.log(action);\n        switch (action.type) {\n            case Actions.ADD_NODE: {\n                const newNode = new TabNode(this, action.data.json, true);\n                const toNode = this._idMap[action.data.toNode] as Node & IDraggable;\n                if (toNode instanceof TabSetNode || toNode instanceof BorderNode || toNode instanceof RowNode) {\n                    toNode.drop(newNode, DockLocation.getByName(action.data.location), action.data.index, action.data.select);\n                    returnVal = newNode;\n                }\n                break;\n            }\n            case Actions.MOVE_NODE: {\n                const fromNode = this._idMap[action.data.fromNode] as Node & IDraggable;\n                if (fromNode instanceof TabNode || fromNode instanceof TabSetNode) {\n                    const toNode = this._idMap[action.data.toNode] as Node & IDropTarget;\n                    if (toNode instanceof TabSetNode || toNode instanceof BorderNode || toNode instanceof RowNode) {\n                        toNode.drop(fromNode, DockLocation.getByName(action.data.location), action.data.index, action.data.select);\n                    }\n                }\n                break;\n            }\n            case Actions.DELETE_TAB: {\n                const node = this._idMap[action.data.node];\n                if (node instanceof TabNode) {\n                    node._delete();\n                }\n                break;\n            }\n            case Actions.DELETE_TABSET: {\n                const node = this._idMap[action.data.node];\n\n                if (node instanceof TabSetNode) {\n                    // first delete all child tabs that are closeable\n                    const children = [...node.getChildren()];\n                    for (let i = 0; i < children.length; i++) {\n                        const child = children[i];\n                        if ((child as TabNode).isEnableClose()) {\n                            (child as TabNode)._delete();\n                        }\n                    }\n\n                    if (node.getChildren().length === 0) {\n                        node._delete();\n                    }\n                    this._tidy();\n                }\n                break;\n            }\n            case Actions.FLOAT_TAB: {\n                const node = this._idMap[action.data.node];\n                if (node instanceof TabNode) {\n                    node._setFloating(true);\n                    adjustSelectedIndexAfterFloat(node);\n                }\n                break;\n            }\n            case Actions.UNFLOAT_TAB: {\n                const node = this._idMap[action.data.node];\n                if (node instanceof TabNode) {\n                    node._setFloating(false);\n                    adjustSelectedIndexAfterDock(node);\n                }\n                break;\n            }\n            case Actions.RENAME_TAB: {\n                const node = this._idMap[action.data.node];\n                if (node instanceof TabNode) {\n                    node._setName(action.data.text);\n                }\n                break;\n            }\n            case Actions.SELECT_TAB: {\n                const tabNode = this._idMap[action.data.tabNode];\n                if (tabNode instanceof TabNode) {\n                    const parent = tabNode.getParent() as Node;\n                    const pos = parent.getChildren().indexOf(tabNode);\n\n                    if (parent instanceof BorderNode) {\n                        if (parent.getSelected() === pos) {\n                            parent._setSelected(-1);\n                        } else {\n                            parent._setSelected(pos);\n                        }\n                    } else if (parent instanceof TabSetNode) {\n                        if (parent.getSelected() !== pos) {\n                            parent._setSelected(pos);\n                        }\n                        this._activeTabSet = parent;\n                    }\n                }\n                break;\n            }\n            case Actions.SET_ACTIVE_TABSET: {\n                const tabsetNode = this._idMap[action.data.tabsetNode];\n                if (tabsetNode instanceof TabSetNode) {\n                    this._activeTabSet = tabsetNode;\n                }\n                break;\n            }\n            case Actions.ADJUST_SPLIT: {\n                const node1 = this._idMap[action.data.node1];\n                const node2 = this._idMap[action.data.node2];\n\n                if ((node1 instanceof TabSetNode || node1 instanceof RowNode) && (node2 instanceof TabSetNode || node2 instanceof RowNode)) {\n                    this._adjustSplitSide(node1, action.data.weight1, action.data.pixelWidth1);\n                    this._adjustSplitSide(node2, action.data.weight2, action.data.pixelWidth2);\n                }\n                break;\n            }\n            case Actions.ADJUST_BORDER_SPLIT: {\n                const node = this._idMap[action.data.node];\n                if (node instanceof BorderNode) {\n                    node._setSize(action.data.pos);\n                }\n                break;\n            }\n            case Actions.MAXIMIZE_TOGGLE: {\n                const node = this._idMap[action.data.node];\n                if (node instanceof TabSetNode) {\n                    if (node === this._maximizedTabSet) {\n                        this._maximizedTabSet = undefined;\n                    } else {\n                        this._maximizedTabSet = node;\n                        this._activeTabSet = node;\n                    }\n                }\n\n                break;\n            }\n            case Actions.UPDATE_MODEL_ATTRIBUTES: {\n                this._updateAttrs(action.data.json);\n                break;\n            }\n\n            case Actions.UPDATE_NODE_ATTRIBUTES: {\n                const node = this._idMap[action.data.node];\n                node._updateAttrs(action.data.json);\n                break;\n            }\n            default:\n                break;\n        }\n\n        this._updateIdMap();\n\n        if (this._changeListener !== undefined) {\n            this._changeListener();\n        }\n\n        return returnVal;\n    }\n\n    /** @internal */\n    _updateIdMap() {\n        // regenerate idMap to stop it building up\n        this._idMap = {};\n        this.visitNodes((node) => (this._idMap[node.getId()] = node));\n        // console.log(JSON.stringify(Object.keys(this._idMap)));\n    }\n\n    /** @internal */\n    _adjustSplitSide(node: TabSetNode | RowNode, weight: number, pixels: number) {\n        node._setWeight(weight);\n        if (node.getWidth() != null && node.getOrientation() === Orientation.VERT) {\n            node._updateAttrs({ width: pixels });\n        } else if (node.getHeight() != null && node.getOrientation() === Orientation.HORZ) {\n            node._updateAttrs({ height: pixels });\n        }\n    }\n\n    /**\n     * Converts the model to a json object\n     * @returns {IJsonModel} json object that represents this model\n     */\n    toJson(): IJsonModel {\n        const global: any = {};\n        Model._attributeDefinitions.toJson(global, this._attributes);\n\n        // save state of nodes\n        this.visitNodes((node) => {\n            node._fireEvent(\"save\", undefined);\n        });\n\n        return { global, borders: this._borders._toJson(), layout: (this._root as RowNode).toJson() };\n    }\n\n    getSplitterSize() {\n        let splitterSize = this._attributes.splitterSize as number;\n        if (splitterSize === -1) {\n            // use defaults\n            splitterSize = this._pointerFine ? 8 : 12; // larger for mobile\n        }\n        return splitterSize;\n    }\n\n    isLegacyOverflowMenu() {\n        return this._attributes.legacyOverflowMenu as boolean;\n    }\n\n    getSplitterExtra() {\n        return this._attributes.splitterExtra as number;\n    }\n\n    isEnableEdgeDock() {\n        return this._attributes.enableEdgeDock as boolean;\n    }\n\n    /** @internal */\n    _addNode(node: Node) {\n        const id = node.getId();\n        if (this._idMap[id] !== undefined) {\n            throw new Error(`Error: each node must have a unique id, duplicate id:${node.getId()}`);\n        }\n\n        if (node.getType() !== \"splitter\") {\n            this._idMap[id] = node;\n        }\n    }\n\n    /** @internal */\n    _layout(rect: Rect, metrics: ILayoutMetrics) {\n        // let start = Date.now();\n        this._borderRects = this._borders._layoutBorder({ outer: rect, inner: rect }, metrics);\n        rect = this._borderRects.inner.removeInsets(this._getAttribute(\"marginInsets\"));\n\n        this._root?.calcMinSize();\n        (this._root as RowNode)._layout(rect, metrics);\n        // console.log(\"layout time: \" + (Date.now() - start));\n        return rect;\n    }\n\n    /** @internal */\n    _findDropTargetNode(dragNode: Node & IDraggable, x: number, y: number) {\n        let node = (this._root as RowNode)._findDropTargetNode(dragNode, x, y);\n        if (node === undefined) {\n            node = this._borders._findDropTargetNode(dragNode, x, y);\n        }\n        return node;\n    }\n\n    /** @internal */\n    _tidy() {\n        // console.log(\"before _tidy\", this.toString());\n        (this._root as RowNode)._tidy();\n        // console.log(\"after _tidy\", this.toString());\n    }\n\n    /** @internal */\n    _updateAttrs(json: any) {\n        Model._attributeDefinitions.update(json, this._attributes);\n    }\n\n    /** @internal */\n    _nextUniqueId() {\n        return '#' + getUUID();\n    }\n\n    /** @internal */\n    _getAttribute(name: string): any {\n        return this._attributes[name];\n    }\n\n    /**\n     * Sets a function to allow/deny dropping a node\n     * @param onAllowDrop function that takes the drag node and DropInfo and returns true if the drop is allowed\n     */\n    setOnAllowDrop(onAllowDrop: (dragNode: Node, dropInfo: DropInfo) => boolean) {\n        this._onAllowDrop = onAllowDrop;\n    }\n\n    /** @internal */\n    _getOnAllowDrop() {\n        return this._onAllowDrop;\n    }\n\n    /**\n     * set callback called when a new TabSet is created.\n     * The tabNode can be undefined if it's the auto created first tabset in the root row (when the last\n     * tab is deleted, the root tabset can be recreated)\n     * @param onCreateTabSet \n     */\n    setOnCreateTabSet(onCreateTabSet: (tabNode?: TabNode) => ITabSetAttributes) {\n        this._onCreateTabSet = onCreateTabSet;\n    }\n\n    /** @internal */\n    _getOnCreateTabSet() {\n        return this._onCreateTabSet;\n    }\n\n    static toTypescriptInterfaces() {\n        console.log(Model._attributeDefinitions.toTypescriptInterface(\"Global\", undefined));\n        console.log(RowNode.getAttributeDefinitions().toTypescriptInterface(\"Row\", Model._attributeDefinitions));\n        console.log(TabSetNode.getAttributeDefinitions().toTypescriptInterface(\"TabSet\", Model._attributeDefinitions));\n        console.log(TabNode.getAttributeDefinitions().toTypescriptInterface(\"Tab\", Model._attributeDefinitions));\n        console.log(BorderNode.getAttributeDefinitions().toTypescriptInterface(\"Border\", Model._attributeDefinitions));\n    }\n\n    toString() {\n        return JSON.stringify(this.toJson());\n    }\n}\n\n"]},"metadata":{},"sourceType":"script"}