{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useTabOverflow = void 0;\n\nvar React = require(\"react\");\n\nvar Rect_1 = require(\"../Rect\");\n\nvar TabSetNode_1 = require(\"../model/TabSetNode\");\n\nvar Orientation_1 = require(\"../Orientation\");\n/** @internal */\n\n\nvar useTabOverflow = function (node, orientation, toolbarRef, stickyButtonsRef) {\n  var firstRender = React.useRef(true);\n  var tabsTruncated = React.useRef(false);\n  var lastRect = React.useRef(new Rect_1.Rect(0, 0, 0, 0));\n  var selfRef = React.useRef(null);\n\n  var _a = React.useState(0),\n      position = _a[0],\n      setPosition = _a[1];\n\n  var userControlledLeft = React.useRef(false);\n\n  var _b = React.useState([]),\n      hiddenTabs = _b[0],\n      setHiddenTabs = _b[1];\n\n  var lastHiddenCount = React.useRef(0); // if selected node or tabset/border rectangle change then unset usercontrolled (so selected tab will be kept in view)\n\n  React.useLayoutEffect(function () {\n    userControlledLeft.current = false;\n  }, [node.getSelectedNode(), node.getRect().width, node.getRect().height]);\n  React.useLayoutEffect(function () {\n    updateVisibleTabs();\n  });\n  React.useEffect(function () {\n    var instance = selfRef.current;\n    instance.addEventListener('wheel', onWheel);\n    return function () {\n      instance.removeEventListener('wheel', onWheel);\n    };\n  }, []); // needed to prevent default mouse wheel over tabset/border (cannot do with react event?)\n\n  var onWheel = function (event) {\n    event.preventDefault();\n  };\n\n  var getNear = function (rect) {\n    if (orientation === Orientation_1.Orientation.HORZ) {\n      return rect.x;\n    } else {\n      return rect.y;\n    }\n  };\n\n  var getFar = function (rect) {\n    if (orientation === Orientation_1.Orientation.HORZ) {\n      return rect.getRight();\n    } else {\n      return rect.getBottom();\n    }\n  };\n\n  var getSize = function (rect) {\n    if (orientation === Orientation_1.Orientation.HORZ) {\n      return rect.width;\n    } else {\n      return rect.height;\n    }\n  };\n\n  var updateVisibleTabs = function () {\n    var tabMargin = 2;\n\n    if (firstRender.current === true) {\n      tabsTruncated.current = false;\n    }\n\n    var nodeRect = node instanceof TabSetNode_1.TabSetNode ? node.getRect() : node.getTabHeaderRect();\n    var lastChild = node.getChildren()[node.getChildren().length - 1];\n    var stickyButtonsSize = stickyButtonsRef.current === null ? 0 : getSize(stickyButtonsRef.current.getBoundingClientRect());\n\n    if (firstRender.current === true || lastHiddenCount.current === 0 && hiddenTabs.length !== 0 || nodeRect.width !== lastRect.current.width || // incase rect changed between first render and second\n    nodeRect.height !== lastRect.current.height) {\n      lastHiddenCount.current = hiddenTabs.length;\n      lastRect.current = nodeRect;\n      var enabled = node instanceof TabSetNode_1.TabSetNode ? node.isEnableTabStrip() === true : true;\n      var endPos = getFar(nodeRect) - stickyButtonsSize;\n\n      if (toolbarRef.current !== null) {\n        endPos -= getSize(toolbarRef.current.getBoundingClientRect());\n      }\n\n      if (enabled && node.getChildren().length > 0) {\n        if (hiddenTabs.length === 0 && position === 0 && getFar(lastChild.getTabRect()) + tabMargin < endPos) {\n          return; // nothing to do all tabs are shown in available space\n        }\n\n        var shiftPos = 0;\n        var selectedTab = node.getSelectedNode();\n\n        if (selectedTab && !userControlledLeft.current) {\n          var selectedRect = selectedTab.getTabRect();\n          var selectedStart = getNear(selectedRect) - tabMargin;\n          var selectedEnd = getFar(selectedRect) + tabMargin; // when selected tab is larger than available space then align left\n\n          if (getSize(selectedRect) + 2 * tabMargin >= endPos - getNear(nodeRect)) {\n            shiftPos = getNear(nodeRect) - selectedStart;\n          } else {\n            if (selectedEnd > endPos || selectedStart < getNear(nodeRect)) {\n              if (selectedStart < getNear(nodeRect)) {\n                shiftPos = getNear(nodeRect) - selectedStart;\n              } // use second if statement to prevent tab moving back then forwards if not enough space for single tab\n\n\n              if (selectedEnd + shiftPos > endPos) {\n                shiftPos = endPos - selectedEnd;\n              }\n            }\n          }\n        }\n\n        var extraSpace = Math.max(0, endPos - (getFar(lastChild.getTabRect()) + tabMargin + shiftPos));\n        var newPosition = Math.min(0, position + shiftPos + extraSpace); // find hidden tabs\n\n        var diff = newPosition - position;\n        var hidden = [];\n\n        for (var i = 0; i < node.getChildren().length; i++) {\n          var child = node.getChildren()[i];\n\n          if (getNear(child.getTabRect()) + diff < getNear(nodeRect) || getFar(child.getTabRect()) + diff > endPos) {\n            hidden.push({\n              node: child,\n              index: i\n            });\n          }\n        }\n\n        if (hidden.length > 0) {\n          tabsTruncated.current = true;\n        }\n\n        firstRender.current = false; // need to do a second render\n\n        setHiddenTabs(hidden);\n        setPosition(newPosition);\n      }\n    } else {\n      firstRender.current = true;\n    }\n  };\n\n  var onMouseWheel = function (event) {\n    var delta = 0;\n\n    if (Math.abs(event.deltaX) > Math.abs(event.deltaY)) {\n      delta = -event.deltaX;\n    } else {\n      delta = -event.deltaY;\n    }\n\n    if (event.deltaMode === 1) {\n      // DOM_DELTA_LINE\t0x01\tThe delta values are specified in lines.\n      delta *= 40;\n    }\n\n    setPosition(position + delta);\n    userControlledLeft.current = true;\n    event.stopPropagation();\n  };\n\n  return {\n    selfRef: selfRef,\n    position: position,\n    userControlledLeft: userControlledLeft,\n    hiddenTabs: hiddenTabs,\n    onMouseWheel: onMouseWheel,\n    tabsTruncated: tabsTruncated.current\n  };\n};\n\nexports.useTabOverflow = useTabOverflow;","map":{"version":3,"mappings":"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","names":["useTabOverflow","node","orientation","toolbarRef","stickyButtonsRef","firstRender","React","useRef","tabsTruncated","lastRect","Rect_1","selfRef","useState","position","setPosition","userControlledLeft","hiddenTabs","setHiddenTabs","lastHiddenCount","useLayoutEffect","current","getSelectedNode","getRect","width","height","updateVisibleTabs","useEffect","instance","addEventListener","onWheel","removeEventListener","event","preventDefault","getNear","rect","Orientation_1","HORZ","x","y","getFar","getRight","getBottom","getSize","tabMargin","nodeRect","TabSetNode_1","getTabHeaderRect","lastChild","getChildren","length","stickyButtonsSize","getBoundingClientRect","enabled","isEnableTabStrip","endPos","getTabRect","shiftPos","selectedTab","selectedRect","selectedStart","selectedEnd","extraSpace","Math","max","newPosition","min","diff","hidden","i","child","push","index","onMouseWheel","delta","abs","deltaX","deltaY","deltaMode","stopPropagation","exports"],"sources":["C:\\Users\\mmorrone\\UnityProjects\\my-app\\node_modules\\flexlayout-react\\src\\view\\TabOverflowHook.tsx"],"sourcesContent":["import * as React from \"react\";\nimport { TabNode } from \"../model/TabNode\";\nimport { Rect } from \"../Rect\";\nimport { TabSetNode } from \"../model/TabSetNode\";\nimport { BorderNode } from \"../model/BorderNode\";\nimport { Orientation } from \"../Orientation\";\n\n/** @internal */\nexport const useTabOverflow = (\n    node: TabSetNode | BorderNode,\n    orientation: Orientation,\n    toolbarRef: React.MutableRefObject<HTMLDivElement | null>,\n    stickyButtonsRef: React.MutableRefObject<HTMLDivElement | null>\n) => {\n    const firstRender = React.useRef<boolean>(true);\n    const tabsTruncated = React.useRef<boolean>(false);\n    const lastRect = React.useRef<Rect>(new Rect(0, 0, 0, 0));\n    const selfRef = React.useRef<HTMLDivElement | null>(null);\n\n    const [position, setPosition] = React.useState<number>(0);\n    const userControlledLeft = React.useRef<boolean>(false);\n    const [hiddenTabs, setHiddenTabs] = React.useState<{ node: TabNode; index: number }[]>([]);\n    const lastHiddenCount = React.useRef<number>(0);\n\n    // if selected node or tabset/border rectangle change then unset usercontrolled (so selected tab will be kept in view)\n    React.useLayoutEffect(() => {\n        userControlledLeft.current = false;\n    }, [node.getSelectedNode(), node.getRect().width, node.getRect().height]);\n\n    React.useLayoutEffect(() => {\n        updateVisibleTabs();\n    });\n\n    React.useEffect(() => {\n        const instance = selfRef.current!;\n        instance.addEventListener('wheel', onWheel);\n        return () => {\n            instance.removeEventListener('wheel', onWheel);\n        }\n    }, []);\n\n    // needed to prevent default mouse wheel over tabset/border (cannot do with react event?)\n    const onWheel = (event: Event) => {\n        event.preventDefault();\n    };\n\n    const getNear = (rect: Rect) => {\n        if (orientation === Orientation.HORZ) {\n            return rect.x;\n        } else {\n            return rect.y;\n        }\n    };\n\n    const getFar = (rect: Rect) => {\n        if (orientation === Orientation.HORZ) {\n            return rect.getRight();\n        } else {\n            return rect.getBottom();\n        }\n    };\n\n    const getSize = (rect: DOMRect | Rect) => {\n        if (orientation === Orientation.HORZ) {\n            return rect.width;\n        } else {\n            return rect.height;\n        }\n    };\n\n    const updateVisibleTabs = () => {\n        const tabMargin = 2;\n        if (firstRender.current === true) {\n            tabsTruncated.current = false;\n        }\n        const nodeRect = node instanceof TabSetNode ? node.getRect() : (node as BorderNode).getTabHeaderRect()!;\n        let lastChild = node.getChildren()[node.getChildren().length - 1] as TabNode;\n        const stickyButtonsSize = stickyButtonsRef.current === null ? 0 : getSize(stickyButtonsRef.current!.getBoundingClientRect());\n\n        if (\n            firstRender.current === true ||\n            (lastHiddenCount.current === 0 && hiddenTabs.length !== 0) ||\n            nodeRect.width !== lastRect.current.width || // incase rect changed between first render and second\n            nodeRect.height !== lastRect.current.height\n        ) {\n            lastHiddenCount.current = hiddenTabs.length;\n            lastRect.current = nodeRect;\n            const enabled = node instanceof TabSetNode ? node.isEnableTabStrip() === true : true;\n            let endPos = getFar(nodeRect) - stickyButtonsSize;\n            if (toolbarRef.current !== null) {\n                endPos -= getSize(toolbarRef.current.getBoundingClientRect());\n            }\n            if (enabled && node.getChildren().length > 0) {\n                if (hiddenTabs.length === 0 && position === 0 && getFar(lastChild.getTabRect()!) + tabMargin < endPos) {\n                    return; // nothing to do all tabs are shown in available space\n                }\n\n                let shiftPos = 0;\n\n                const selectedTab = node.getSelectedNode() as TabNode;\n                if (selectedTab && !userControlledLeft.current) {\n                    const selectedRect = selectedTab.getTabRect()!;\n                    const selectedStart = getNear(selectedRect) - tabMargin;\n                    const selectedEnd = getFar(selectedRect) + tabMargin;\n\n                    // when selected tab is larger than available space then align left\n                    if (getSize(selectedRect) + 2 * tabMargin >= endPos - getNear(nodeRect)) {\n                        shiftPos = getNear(nodeRect) - selectedStart;\n                    } else {\n                        if (selectedEnd > endPos || selectedStart < getNear(nodeRect)) {\n                            if (selectedStart < getNear(nodeRect)) {\n                                shiftPos = getNear(nodeRect) - selectedStart;\n                            }\n                            // use second if statement to prevent tab moving back then forwards if not enough space for single tab\n                            if (selectedEnd + shiftPos > endPos) {\n                                shiftPos = endPos - selectedEnd;\n                            }\n                        }\n                    }\n                }\n\n                const extraSpace = Math.max(0, endPos - (getFar(lastChild.getTabRect()!) + tabMargin + shiftPos));\n                const newPosition = Math.min(0, position + shiftPos + extraSpace);\n\n                // find hidden tabs\n                const diff = newPosition - position;\n                const hidden: { node: TabNode; index: number }[] = [];\n                for (let i = 0; i < node.getChildren().length; i++) {\n                    const child = node.getChildren()[i] as TabNode;\n                    if (getNear(child.getTabRect()!) + diff < getNear(nodeRect!) || getFar(child.getTabRect()!) + diff > endPos) {\n                        hidden.push({ node: child, index: i });\n                    }\n                }\n\n                if (hidden.length > 0) {\n                    tabsTruncated.current = true;\n                }\n\n                firstRender.current = false; // need to do a second render\n                setHiddenTabs(hidden);\n                setPosition(newPosition);\n            }\n        } else {\n            firstRender.current = true;\n        }\n    };\n\n    const onMouseWheel = (event: React.WheelEvent<HTMLDivElement>) => {\n        let delta = 0;\n        if (Math.abs(event.deltaX) > Math.abs(event.deltaY)) {\n            delta = -event.deltaX;\n        } else {\n            delta = -event.deltaY;\n        }\n        if (event.deltaMode === 1) {\n            // DOM_DELTA_LINE\t0x01\tThe delta values are specified in lines.\n            delta *= 40;\n        }\n        setPosition(position + delta);\n        userControlledLeft.current = true;\n        event.stopPropagation();\n    };\n\n    return { selfRef, position, userControlledLeft, hiddenTabs, onMouseWheel, tabsTruncated: tabsTruncated.current };\n};\n"]},"metadata":{},"sourceType":"script"}