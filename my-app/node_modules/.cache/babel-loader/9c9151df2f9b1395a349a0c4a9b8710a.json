{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Layout = void 0;\n\nvar React = require(\"react\");\n\nvar ReactDOM = require(\"react-dom\");\n\nvar DockLocation_1 = require(\"../DockLocation\");\n\nvar DragDrop_1 = require(\"../DragDrop\");\n\nvar Actions_1 = require(\"../model/Actions\");\n\nvar BorderNode_1 = require(\"../model/BorderNode\");\n\nvar SplitterNode_1 = require(\"../model/SplitterNode\");\n\nvar TabNode_1 = require(\"../model/TabNode\");\n\nvar TabSetNode_1 = require(\"../model/TabSetNode\");\n\nvar Rect_1 = require(\"../Rect\");\n\nvar Types_1 = require(\"../Types\");\n\nvar BorderTabSet_1 = require(\"./BorderTabSet\");\n\nvar Splitter_1 = require(\"./Splitter\");\n\nvar Tab_1 = require(\"./Tab\");\n\nvar TabSet_1 = require(\"./TabSet\");\n\nvar FloatingWindow_1 = require(\"./FloatingWindow\");\n\nvar FloatingWindowTab_1 = require(\"./FloatingWindowTab\");\n\nvar TabFloating_1 = require(\"./TabFloating\");\n\nvar Orientation_1 = require(\"../Orientation\");\n\nvar Icons_1 = require(\"./Icons\");\n\nvar TabButtonStamp_1 = require(\"./TabButtonStamp\");\n\nvar defaultIcons = {\n  close: React.createElement(Icons_1.CloseIcon, null),\n  closeTabset: React.createElement(Icons_1.CloseIcon, null),\n  popout: React.createElement(Icons_1.PopoutIcon, null),\n  maximize: React.createElement(Icons_1.MaximizeIcon, null),\n  restore: React.createElement(Icons_1.RestoreIcon, null),\n  more: React.createElement(Icons_1.OverflowIcon, null)\n}; // Popout windows work in latest browsers based on webkit (Chrome, Opera, Safari, latest Edge) and Firefox. They do\n// not work on any version if IE or the original Edge browser\n// Assume any recent desktop browser not IE or original Edge will work\n\n/** @internal */\n// @ts-ignore\n\nvar isIEorEdge = typeof window !== \"undefined\" && (window.document.documentMode || /Edge\\//.test(window.navigator.userAgent));\n/** @internal */\n\nvar isDesktop = typeof window !== \"undefined\" && window.matchMedia && window.matchMedia(\"(hover: hover) and (pointer: fine)\").matches;\n/** @internal */\n\nvar defaultSupportsPopout = isDesktop && !isIEorEdge;\n/**\n * A React component that hosts a multi-tabbed layout\n */\n\nvar Layout =\n/** @class */\nfunction (_super) {\n  __extends(Layout, _super);\n\n  function Layout(props) {\n    var _this = _super.call(this, props) || this;\n    /** @internal */\n\n\n    _this.firstMove = false;\n    /** @internal */\n\n    _this.dragRectRendered = true;\n    /** @internal */\n\n    _this.dragDivText = undefined;\n    /** @internal */\n\n    _this.edgeRectLength = 100;\n    /** @internal */\n\n    _this.edgeRectWidth = 10;\n    /** @internal */\n\n    _this.edgesShown = false;\n    /** @internal */\n\n    _this.onModelChange = function () {\n      _this.forceUpdate();\n\n      if (_this.props.onModelChange) {\n        _this.props.onModelChange(_this.props.model);\n      }\n    };\n    /** @internal */\n\n\n    _this.updateRect = function (domRect) {\n      if (domRect === void 0) {\n        domRect = _this.getDomRect();\n      }\n\n      var rect = new Rect_1.Rect(0, 0, domRect.width, domRect.height);\n\n      if (!rect.equals(_this.state.rect) && rect.width !== 0 && rect.height !== 0) {\n        _this.setState({\n          rect: rect\n        });\n      }\n    };\n    /** @internal */\n\n\n    _this.updateLayoutMetrics = function () {\n      if (_this.findHeaderBarSizeRef.current) {\n        var headerBarSize = _this.findHeaderBarSizeRef.current.getBoundingClientRect().height;\n\n        if (headerBarSize !== _this.state.calculatedHeaderBarSize) {\n          _this.setState({\n            calculatedHeaderBarSize: headerBarSize\n          });\n        }\n      }\n\n      if (_this.findTabBarSizeRef.current) {\n        var tabBarSize = _this.findTabBarSizeRef.current.getBoundingClientRect().height;\n\n        if (tabBarSize !== _this.state.calculatedTabBarSize) {\n          _this.setState({\n            calculatedTabBarSize: tabBarSize\n          });\n        }\n      }\n\n      if (_this.findBorderBarSizeRef.current) {\n        var borderBarSize = _this.findBorderBarSizeRef.current.getBoundingClientRect().height;\n\n        if (borderBarSize !== _this.state.calculatedBorderBarSize) {\n          _this.setState({\n            calculatedBorderBarSize: borderBarSize\n          });\n        }\n      }\n    };\n    /** @internal */\n\n\n    _this.getClassName = function (defaultClassName) {\n      if (_this.props.classNameMapper === undefined) {\n        return defaultClassName;\n      } else {\n        return _this.props.classNameMapper(defaultClassName);\n      }\n    };\n    /** @internal */\n\n\n    _this.onCloseWindow = function (id) {\n      _this.doAction(Actions_1.Actions.unFloatTab(id));\n\n      try {\n        _this.props.model.getNodeById(id)._setWindow(undefined);\n      } catch (e) {// catch incase it was a model change\n      }\n    };\n    /** @internal */\n\n\n    _this.onSetWindow = function (id, window) {\n      _this.props.model.getNodeById(id)._setWindow(window);\n    };\n    /** @internal */\n\n\n    _this.onCancelAdd = function () {\n      var _a, _b;\n\n      var rootdiv = _this.selfRef.current;\n      rootdiv.removeChild(_this.dragDiv);\n      _this.dragDiv = undefined;\n\n      _this.hidePortal();\n\n      if (_this.fnNewNodeDropped != null) {\n        _this.fnNewNodeDropped();\n\n        _this.fnNewNodeDropped = undefined;\n      }\n\n      try {\n        (_b = (_a = _this.customDrop) === null || _a === void 0 ? void 0 : _a.invalidated) === null || _b === void 0 ? void 0 : _b.call(_a);\n      } catch (e) {\n        console.error(e);\n      }\n\n      DragDrop_1.DragDrop.instance.hideGlass();\n      _this.newTabJson = undefined;\n      _this.customDrop = undefined;\n    };\n    /** @internal */\n\n\n    _this.onCancelDrag = function (wasDragging) {\n      var _a, _b;\n\n      if (wasDragging) {\n        var rootdiv = _this.selfRef.current;\n\n        try {\n          rootdiv.removeChild(_this.outlineDiv);\n        } catch (e) {}\n\n        try {\n          rootdiv.removeChild(_this.dragDiv);\n        } catch (e) {}\n\n        _this.dragDiv = undefined;\n\n        _this.hidePortal();\n\n        _this.hideEdges(rootdiv);\n\n        if (_this.fnNewNodeDropped != null) {\n          _this.fnNewNodeDropped();\n\n          _this.fnNewNodeDropped = undefined;\n        }\n\n        try {\n          (_b = (_a = _this.customDrop) === null || _a === void 0 ? void 0 : _a.invalidated) === null || _b === void 0 ? void 0 : _b.call(_a);\n        } catch (e) {\n          console.error(e);\n        }\n\n        DragDrop_1.DragDrop.instance.hideGlass();\n        _this.newTabJson = undefined;\n        _this.customDrop = undefined;\n      }\n\n      _this.setState({\n        showHiddenBorder: DockLocation_1.DockLocation.CENTER\n      });\n    };\n    /** @internal */\n\n\n    _this.onDragDivMouseDown = function (event) {\n      event.preventDefault();\n\n      _this.dragStart(event, _this.dragDivText, TabNode_1.TabNode._fromJson(_this.newTabJson, _this.props.model, false), true, undefined, undefined);\n    };\n    /** @internal */\n\n\n    _this.dragStart = function (event, dragDivText, node, allowDrag, onClick, onDoubleClick) {\n      if (_this.props.model.getMaximizedTabset() !== undefined || !allowDrag) {\n        DragDrop_1.DragDrop.instance.startDrag(event, undefined, undefined, undefined, undefined, onClick, onDoubleClick, _this.currentDocument, _this.selfRef.current);\n      } else {\n        _this.dragNode = node;\n        _this.dragDivText = dragDivText;\n        DragDrop_1.DragDrop.instance.startDrag(event, _this.onDragStart, _this.onDragMove, _this.onDragEnd, _this.onCancelDrag, onClick, onDoubleClick, _this.currentDocument, _this.selfRef.current);\n      }\n    };\n    /** @internal */\n\n\n    _this.dragRectRender = function (text, node, json, onRendered) {\n      var content;\n\n      if (text !== undefined) {\n        content = React.createElement(\"div\", {\n          style: {\n            whiteSpace: \"pre\"\n          }\n        }, text.replace(\"<br>\", \"\\n\"));\n      } else {\n        if (node && node instanceof TabNode_1.TabNode) {\n          content = React.createElement(TabButtonStamp_1.TabButtonStamp, {\n            node: node,\n            layout: _this,\n            iconFactory: _this.props.iconFactory,\n            titleFactory: _this.props.titleFactory\n          });\n        }\n      }\n\n      if (_this.props.onRenderDragRect !== undefined) {\n        var customContent = _this.props.onRenderDragRect(content, node, json);\n\n        if (customContent !== undefined) {\n          content = customContent;\n        }\n      } // hide div until the render is complete\n\n\n      _this.dragDiv.style.visibility = \"hidden\";\n      _this.dragRectRendered = false;\n\n      _this.showPortal(React.createElement(DragRectRenderWrapper // wait for it to be rendered\n      , {\n        // wait for it to be rendered\n        onRendered: function () {\n          _this.dragRectRendered = true;\n          onRendered === null || onRendered === void 0 ? void 0 : onRendered();\n        }\n      }, content), _this.dragDiv);\n    };\n    /** @internal */\n\n\n    _this.showPortal = function (control, element) {\n      var portal = ReactDOM.createPortal(control, element);\n\n      _this.setState({\n        portal: portal\n      });\n    };\n    /** @internal */\n\n\n    _this.hidePortal = function () {\n      _this.setState({\n        portal: undefined\n      });\n    };\n    /** @internal */\n\n\n    _this.onDragStart = function () {\n      _this.dropInfo = undefined;\n      _this.customDrop = undefined;\n      var rootdiv = _this.selfRef.current;\n      _this.outlineDiv = _this.currentDocument.createElement(\"div\");\n      _this.outlineDiv.className = _this.getClassName(Types_1.CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n      _this.outlineDiv.style.visibility = \"hidden\";\n      rootdiv.appendChild(_this.outlineDiv);\n\n      if (_this.dragDiv == null) {\n        _this.dragDiv = _this.currentDocument.createElement(\"div\");\n        _this.dragDiv.className = _this.getClassName(Types_1.CLASSES.FLEXLAYOUT__DRAG_RECT);\n\n        _this.dragDiv.setAttribute(\"data-layout-path\", \"/drag-rectangle\");\n\n        _this.dragRectRender(_this.dragDivText, _this.dragNode, _this.newTabJson);\n\n        rootdiv.appendChild(_this.dragDiv);\n      } // add edge indicators\n\n\n      _this.showEdges(rootdiv);\n\n      if (_this.dragNode !== undefined && _this.dragNode instanceof TabNode_1.TabNode && _this.dragNode.getTabRect() !== undefined) {\n        _this.dragNode.getTabRect().positionElement(_this.outlineDiv);\n      }\n\n      _this.firstMove = true;\n      return true;\n    };\n    /** @internal */\n\n\n    _this.onDragMove = function (event) {\n      if (_this.firstMove === false) {\n        var speed = _this.props.model._getAttribute(\"tabDragSpeed\");\n\n        _this.outlineDiv.style.transition = \"top \".concat(speed, \"s, left \").concat(speed, \"s, width \").concat(speed, \"s, height \").concat(speed, \"s\");\n      }\n\n      _this.firstMove = false;\n\n      var clientRect = _this.selfRef.current.getBoundingClientRect();\n\n      var pos = {\n        x: event.clientX - clientRect.left,\n        y: event.clientY - clientRect.top\n      };\n\n      _this.checkForBorderToShow(pos.x, pos.y); // keep it between left & right\n\n\n      var dragRect = _this.dragDiv.getBoundingClientRect();\n\n      var newLeft = pos.x - dragRect.width / 2;\n\n      if (newLeft + dragRect.width > clientRect.width) {\n        newLeft = clientRect.width - dragRect.width;\n      }\n\n      newLeft = Math.max(0, newLeft);\n      _this.dragDiv.style.left = newLeft + \"px\";\n      _this.dragDiv.style.top = pos.y + 5 + \"px\";\n\n      if (_this.dragRectRendered && _this.dragDiv.style.visibility === \"hidden\") {\n        // make visible once the drag rect has been rendered\n        _this.dragDiv.style.visibility = \"visible\";\n      }\n\n      var dropInfo = _this.props.model._findDropTargetNode(_this.dragNode, pos.x, pos.y);\n\n      if (dropInfo) {\n        if (_this.props.onTabDrag) {\n          _this.handleCustomTabDrag(dropInfo, pos, event);\n        } else {\n          _this.dropInfo = dropInfo;\n          _this.outlineDiv.className = _this.getClassName(dropInfo.className);\n          dropInfo.rect.positionElement(_this.outlineDiv);\n          _this.outlineDiv.style.visibility = \"visible\";\n        }\n      }\n    };\n    /** @internal */\n\n\n    _this.onDragEnd = function (event) {\n      var rootdiv = _this.selfRef.current;\n      rootdiv.removeChild(_this.outlineDiv);\n      rootdiv.removeChild(_this.dragDiv);\n      _this.dragDiv = undefined;\n\n      _this.hidePortal();\n\n      _this.hideEdges(rootdiv);\n\n      DragDrop_1.DragDrop.instance.hideGlass();\n\n      if (_this.dropInfo) {\n        if (_this.customDrop) {\n          _this.newTabJson = undefined;\n\n          try {\n            var _a = _this.customDrop,\n                callback = _a.callback,\n                dragging = _a.dragging,\n                over = _a.over,\n                x = _a.x,\n                y = _a.y,\n                location_1 = _a.location;\n            callback(dragging, over, x, y, location_1);\n\n            if (_this.fnNewNodeDropped != null) {\n              _this.fnNewNodeDropped();\n\n              _this.fnNewNodeDropped = undefined;\n            }\n          } catch (e) {\n            console.error(e);\n          }\n        } else if (_this.newTabJson !== undefined) {\n          var newNode = _this.doAction(Actions_1.Actions.addNode(_this.newTabJson, _this.dropInfo.node.getId(), _this.dropInfo.location, _this.dropInfo.index));\n\n          if (_this.fnNewNodeDropped != null) {\n            _this.fnNewNodeDropped(newNode, event);\n\n            _this.fnNewNodeDropped = undefined;\n          }\n\n          _this.newTabJson = undefined;\n        } else if (_this.dragNode !== undefined) {\n          _this.doAction(Actions_1.Actions.moveNode(_this.dragNode.getId(), _this.dropInfo.node.getId(), _this.dropInfo.location, _this.dropInfo.index));\n        }\n      }\n\n      _this.setState({\n        showHiddenBorder: DockLocation_1.DockLocation.CENTER\n      });\n    };\n\n    _this.props.model._setChangeListener(_this.onModelChange);\n\n    _this.tabIds = [];\n    _this.selfRef = React.createRef();\n    _this.findHeaderBarSizeRef = React.createRef();\n    _this.findTabBarSizeRef = React.createRef();\n    _this.findBorderBarSizeRef = React.createRef();\n    _this.supportsPopout = props.supportsPopout !== undefined ? props.supportsPopout : defaultSupportsPopout;\n    _this.popoutURL = props.popoutURL ? props.popoutURL : \"popout.html\";\n    _this.icons = __assign(__assign({}, defaultIcons), props.icons);\n    _this.firstRender = true;\n    _this.state = {\n      rect: new Rect_1.Rect(0, 0, 0, 0),\n      calculatedHeaderBarSize: 25,\n      calculatedTabBarSize: 26,\n      calculatedBorderBarSize: 30,\n      editingTab: undefined,\n      showHiddenBorder: DockLocation_1.DockLocation.CENTER\n    };\n    _this.onDragEnter = _this.onDragEnter.bind(_this);\n    return _this;\n  }\n  /** @internal */\n\n\n  Layout.prototype.styleFont = function (style) {\n    if (this.props.font) {\n      if (this.selfRef.current) {\n        if (this.props.font.size) {\n          this.selfRef.current.style.setProperty(\"--font-size\", this.props.font.size);\n        }\n\n        if (this.props.font.family) {\n          this.selfRef.current.style.setProperty(\"--font-family\", this.props.font.family);\n        }\n      }\n\n      if (this.props.font.style) {\n        style.fontStyle = this.props.font.style;\n      }\n\n      if (this.props.font.weight) {\n        style.fontWeight = this.props.font.weight;\n      }\n    }\n\n    return style;\n  };\n  /** @internal */\n\n\n  Layout.prototype.doAction = function (action) {\n    if (this.props.onAction !== undefined) {\n      var outcome = this.props.onAction(action);\n\n      if (outcome !== undefined) {\n        return this.props.model.doAction(outcome);\n      }\n\n      return undefined;\n    } else {\n      return this.props.model.doAction(action);\n    }\n  };\n  /** @internal */\n\n\n  Layout.prototype.componentDidMount = function () {\n    var _this = this;\n\n    this.updateRect();\n    this.updateLayoutMetrics(); // need to re-render if size changes\n\n    this.currentDocument = this.selfRef.current.ownerDocument;\n    this.currentWindow = this.currentDocument.defaultView;\n    this.resizeObserver = new ResizeObserver(function (entries) {\n      _this.updateRect(entries[0].contentRect);\n    });\n    this.resizeObserver.observe(this.selfRef.current);\n  };\n  /** @internal */\n\n\n  Layout.prototype.componentDidUpdate = function () {\n    this.updateLayoutMetrics();\n\n    if (this.props.model !== this.previousModel) {\n      if (this.previousModel !== undefined) {\n        this.previousModel._setChangeListener(undefined); // stop listening to old model\n\n      }\n\n      this.props.model._setChangeListener(this.onModelChange);\n\n      this.previousModel = this.props.model;\n    } // console.log(\"Layout time: \" + this.layoutTime + \"ms Render time: \" + (Date.now() - this.start) + \"ms\");\n\n  };\n  /** @internal */\n\n\n  Layout.prototype.getCurrentDocument = function () {\n    return this.currentDocument;\n  };\n  /** @internal */\n\n\n  Layout.prototype.getDomRect = function () {\n    return this.selfRef.current.getBoundingClientRect();\n  };\n  /** @internal */\n\n\n  Layout.prototype.getRootDiv = function () {\n    return this.selfRef.current;\n  };\n  /** @internal */\n\n\n  Layout.prototype.isSupportsPopout = function () {\n    return this.supportsPopout;\n  };\n  /** @internal */\n\n\n  Layout.prototype.isRealtimeResize = function () {\n    var _a;\n\n    return (_a = this.props.realtimeResize) !== null && _a !== void 0 ? _a : false;\n  };\n  /** @internal */\n\n\n  Layout.prototype.onTabDrag = function () {\n    var _a, _b;\n\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    return (_b = (_a = this.props).onTabDrag) === null || _b === void 0 ? void 0 : _b.call.apply(_b, __spreadArray([_a], args, false));\n  };\n  /** @internal */\n\n\n  Layout.prototype.getPopoutURL = function () {\n    return this.popoutURL;\n  };\n  /** @internal */\n\n\n  Layout.prototype.componentWillUnmount = function () {\n    var _a;\n\n    (_a = this.resizeObserver) === null || _a === void 0 ? void 0 : _a.unobserve(this.selfRef.current);\n  };\n  /** @internal */\n\n\n  Layout.prototype.setEditingTab = function (tabNode) {\n    this.setState({\n      editingTab: tabNode\n    });\n  };\n  /** @internal */\n\n\n  Layout.prototype.getEditingTab = function () {\n    return this.state.editingTab;\n  };\n  /** @internal */\n\n\n  Layout.prototype.render = function () {\n    // first render will be used to find the size (via selfRef)\n    if (this.firstRender) {\n      this.firstRender = false;\n      return React.createElement(\"div\", {\n        ref: this.selfRef,\n        className: this.getClassName(Types_1.CLASSES.FLEXLAYOUT__LAYOUT)\n      }, this.metricsElements());\n    }\n\n    this.props.model._setPointerFine(window && window.matchMedia && window.matchMedia(\"(pointer: fine)\").matches); // this.start = Date.now();\n\n\n    var borderComponents = [];\n    var tabSetComponents = [];\n    var floatingWindows = [];\n    var tabComponents = {};\n    var splitterComponents = [];\n    var metrics = {\n      headerBarSize: this.state.calculatedHeaderBarSize,\n      tabBarSize: this.state.calculatedTabBarSize,\n      borderBarSize: this.state.calculatedBorderBarSize\n    };\n\n    this.props.model._setShowHiddenBorder(this.state.showHiddenBorder);\n\n    this.centerRect = this.props.model._layout(this.state.rect, metrics);\n    this.renderBorder(this.props.model.getBorderSet(), borderComponents, tabComponents, floatingWindows, splitterComponents);\n    this.renderChildren(\"\", this.props.model.getRoot(), tabSetComponents, tabComponents, floatingWindows, splitterComponents);\n\n    if (this.edgesShown) {\n      this.repositionEdges(this.state.rect);\n    }\n\n    var nextTopIds = [];\n    var nextTopIdsMap = {}; // Keep any previous tabs in the same DOM order as before, removing any that have been deleted\n\n    for (var _i = 0, _a = this.tabIds; _i < _a.length; _i++) {\n      var t = _a[_i];\n\n      if (tabComponents[t]) {\n        nextTopIds.push(t);\n        nextTopIdsMap[t] = t;\n      }\n    }\n\n    this.tabIds = nextTopIds; // Add tabs that have been added to the DOM\n\n    for (var _b = 0, _c = Object.keys(tabComponents); _b < _c.length; _b++) {\n      var t = _c[_b];\n\n      if (!nextTopIdsMap[t]) {\n        this.tabIds.push(t);\n      }\n    } // this.layoutTime = (Date.now() - this.start);\n\n\n    return React.createElement(\"div\", {\n      ref: this.selfRef,\n      className: this.getClassName(Types_1.CLASSES.FLEXLAYOUT__LAYOUT),\n      onDragEnter: this.props.onExternalDrag ? this.onDragEnter : undefined\n    }, tabSetComponents, this.tabIds.map(function (t) {\n      return tabComponents[t];\n    }), borderComponents, splitterComponents, floatingWindows, this.metricsElements(), this.state.portal);\n  };\n  /** @internal */\n\n\n  Layout.prototype.metricsElements = function () {\n    // used to measure the tab and border tab sizes\n    var fontStyle = this.styleFont({\n      visibility: \"hidden\"\n    });\n    return React.createElement(React.Fragment, null, React.createElement(\"div\", {\n      key: \"findHeaderBarSize\",\n      ref: this.findHeaderBarSizeRef,\n      style: fontStyle,\n      className: this.getClassName(Types_1.CLASSES.FLEXLAYOUT__TABSET_HEADER_SIZER)\n    }, \"FindHeaderBarSize\"), React.createElement(\"div\", {\n      key: \"findTabBarSize\",\n      ref: this.findTabBarSizeRef,\n      style: fontStyle,\n      className: this.getClassName(Types_1.CLASSES.FLEXLAYOUT__TABSET_SIZER)\n    }, \"FindTabBarSize\"), React.createElement(\"div\", {\n      key: \"findBorderBarSize\",\n      ref: this.findBorderBarSizeRef,\n      style: fontStyle,\n      className: this.getClassName(Types_1.CLASSES.FLEXLAYOUT__BORDER_SIZER)\n    }, \"FindBorderBarSize\"));\n  };\n  /** @internal */\n\n\n  Layout.prototype.renderBorder = function (borderSet, borderComponents, tabComponents, floatingWindows, splitterComponents) {\n    for (var _i = 0, _a = borderSet.getBorders(); _i < _a.length; _i++) {\n      var border = _a[_i];\n      var borderPath = \"/border/\".concat(border.getLocation().getName());\n\n      if (border.isShowing()) {\n        borderComponents.push(React.createElement(BorderTabSet_1.BorderTabSet, {\n          key: \"border_\".concat(border.getLocation().getName()),\n          path: borderPath,\n          border: border,\n          layout: this,\n          iconFactory: this.props.iconFactory,\n          titleFactory: this.props.titleFactory,\n          icons: this.icons\n        }));\n\n        var drawChildren = border._getDrawChildren();\n\n        var i = 0;\n        var tabCount = 0;\n\n        for (var _b = 0, drawChildren_1 = drawChildren; _b < drawChildren_1.length; _b++) {\n          var child = drawChildren_1[_b];\n\n          if (child instanceof SplitterNode_1.SplitterNode) {\n            var path = borderPath + \"/s\";\n            splitterComponents.push(React.createElement(Splitter_1.Splitter, {\n              key: child.getId(),\n              layout: this,\n              node: child,\n              path: path\n            }));\n          } else if (child instanceof TabNode_1.TabNode) {\n            var path = borderPath + \"/t\" + tabCount++;\n\n            if (this.supportsPopout && child.isFloating()) {\n              var rect = this._getScreenRect(child);\n\n              floatingWindows.push(React.createElement(FloatingWindow_1.FloatingWindow, {\n                key: child.getId(),\n                url: this.popoutURL,\n                rect: rect,\n                title: child.getName(),\n                id: child.getId(),\n                onSetWindow: this.onSetWindow,\n                onCloseWindow: this.onCloseWindow\n              }, React.createElement(FloatingWindowTab_1.FloatingWindowTab, {\n                layout: this,\n                node: child,\n                factory: this.props.factory\n              })));\n              tabComponents[child.getId()] = React.createElement(TabFloating_1.TabFloating, {\n                key: child.getId(),\n                layout: this,\n                path: path,\n                node: child,\n                selected: i === border.getSelected()\n              });\n            } else {\n              tabComponents[child.getId()] = React.createElement(Tab_1.Tab, {\n                key: child.getId(),\n                layout: this,\n                path: path,\n                node: child,\n                selected: i === border.getSelected(),\n                factory: this.props.factory\n              });\n            }\n          }\n\n          i++;\n        }\n      }\n    }\n  };\n  /** @internal */\n\n\n  Layout.prototype.renderChildren = function (path, node, tabSetComponents, tabComponents, floatingWindows, splitterComponents) {\n    var drawChildren = node._getDrawChildren();\n\n    var splitterCount = 0;\n    var tabCount = 0;\n    var rowCount = 0;\n\n    for (var _i = 0, _a = drawChildren; _i < _a.length; _i++) {\n      var child = _a[_i];\n\n      if (child instanceof SplitterNode_1.SplitterNode) {\n        var newPath = path + \"/s\" + splitterCount++;\n        splitterComponents.push(React.createElement(Splitter_1.Splitter, {\n          key: child.getId(),\n          layout: this,\n          path: newPath,\n          node: child\n        }));\n      } else if (child instanceof TabSetNode_1.TabSetNode) {\n        var newPath = path + \"/ts\" + rowCount++;\n        tabSetComponents.push(React.createElement(TabSet_1.TabSet, {\n          key: child.getId(),\n          layout: this,\n          path: newPath,\n          node: child,\n          iconFactory: this.props.iconFactory,\n          titleFactory: this.props.titleFactory,\n          icons: this.icons\n        }));\n        this.renderChildren(newPath, child, tabSetComponents, tabComponents, floatingWindows, splitterComponents);\n      } else if (child instanceof TabNode_1.TabNode) {\n        var newPath = path + \"/t\" + tabCount++;\n        var selectedTab = child.getParent().getChildren()[child.getParent().getSelected()];\n\n        if (selectedTab === undefined) {\n          // this should not happen!\n          console.warn(\"undefined selectedTab should not happen\");\n        }\n\n        if (this.supportsPopout && child.isFloating()) {\n          var rect = this._getScreenRect(child);\n\n          floatingWindows.push(React.createElement(FloatingWindow_1.FloatingWindow, {\n            key: child.getId(),\n            url: this.popoutURL,\n            rect: rect,\n            title: child.getName(),\n            id: child.getId(),\n            onSetWindow: this.onSetWindow,\n            onCloseWindow: this.onCloseWindow\n          }, React.createElement(FloatingWindowTab_1.FloatingWindowTab, {\n            layout: this,\n            node: child,\n            factory: this.props.factory\n          })));\n          tabComponents[child.getId()] = React.createElement(TabFloating_1.TabFloating, {\n            key: child.getId(),\n            layout: this,\n            path: newPath,\n            node: child,\n            selected: child === selectedTab\n          });\n        } else {\n          tabComponents[child.getId()] = React.createElement(Tab_1.Tab, {\n            key: child.getId(),\n            layout: this,\n            path: newPath,\n            node: child,\n            selected: child === selectedTab,\n            factory: this.props.factory\n          });\n        }\n      } else {\n        // is row\n        var newPath = path + (child.getOrientation() === Orientation_1.Orientation.HORZ ? \"/r\" : \"/c\") + rowCount++;\n        this.renderChildren(newPath, child, tabSetComponents, tabComponents, floatingWindows, splitterComponents);\n      }\n    }\n  };\n  /** @internal */\n\n\n  Layout.prototype._getScreenRect = function (node) {\n    var rect = node.getRect().clone();\n    var bodyRect = this.selfRef.current.getBoundingClientRect();\n    var navHeight = Math.min(80, this.currentWindow.outerHeight - this.currentWindow.innerHeight);\n    var navWidth = Math.min(80, this.currentWindow.outerWidth - this.currentWindow.innerWidth);\n    rect.x = rect.x + bodyRect.x + this.currentWindow.screenX + navWidth;\n    rect.y = rect.y + bodyRect.y + this.currentWindow.screenY + navHeight;\n    return rect;\n  };\n  /**\n   * Adds a new tab to the given tabset\n   * @param tabsetId the id of the tabset where the new tab will be added\n   * @param json the json for the new tab node\n   */\n\n\n  Layout.prototype.addTabToTabSet = function (tabsetId, json) {\n    var tabsetNode = this.props.model.getNodeById(tabsetId);\n\n    if (tabsetNode !== undefined) {\n      this.doAction(Actions_1.Actions.addNode(json, tabsetId, DockLocation_1.DockLocation.CENTER, -1));\n    }\n  };\n  /**\n   * Adds a new tab to the active tabset (if there is one)\n   * @param json the json for the new tab node\n   */\n\n\n  Layout.prototype.addTabToActiveTabSet = function (json) {\n    var tabsetNode = this.props.model.getActiveTabset();\n\n    if (tabsetNode !== undefined) {\n      this.doAction(Actions_1.Actions.addNode(json, tabsetNode.getId(), DockLocation_1.DockLocation.CENTER, -1));\n    }\n  };\n  /**\n   * Adds a new tab by dragging a labeled panel to the drop location, dragging starts immediatelly\n   * @param dragText the text to show on the drag panel\n   * @param json the json for the new tab node\n   * @param onDrop a callback to call when the drag is complete (node and event will be undefined if the drag was cancelled)\n   */\n\n\n  Layout.prototype.addTabWithDragAndDrop = function (dragText, json, onDrop) {\n    this.fnNewNodeDropped = onDrop;\n    this.newTabJson = json;\n    this.dragStart(undefined, dragText, TabNode_1.TabNode._fromJson(json, this.props.model, false), true, undefined, undefined);\n  };\n  /**\n   * Adds a new tab by dragging a labeled panel to the drop location, dragging starts when you\n   * mouse down on the panel\n   *\n   * @param dragText the text to show on the drag panel\n   * @param json the json for the new tab node\n   * @param onDrop a callback to call when the drag is complete (node and event will be undefined if the drag was cancelled)\n   */\n\n\n  Layout.prototype.addTabWithDragAndDropIndirect = function (dragText, json, onDrop) {\n    var _this = this;\n\n    this.fnNewNodeDropped = onDrop;\n    this.newTabJson = json;\n    DragDrop_1.DragDrop.instance.addGlass(this.onCancelAdd);\n    this.dragDivText = dragText;\n    this.dragDiv = this.currentDocument.createElement(\"div\");\n    this.dragDiv.className = this.getClassName(Types_1.CLASSES.FLEXLAYOUT__DRAG_RECT);\n    this.dragDiv.addEventListener(\"mousedown\", this.onDragDivMouseDown);\n    this.dragDiv.addEventListener(\"touchstart\", this.onDragDivMouseDown);\n    this.dragRectRender(this.dragDivText, undefined, this.newTabJson, function () {\n      if (_this.dragDiv) {\n        // now it's been rendered into the dom it can be centered\n        _this.dragDiv.style.visibility = \"visible\";\n\n        var domRect = _this.dragDiv.getBoundingClientRect();\n\n        var r = new Rect_1.Rect(0, 0, domRect === null || domRect === void 0 ? void 0 : domRect.width, domRect === null || domRect === void 0 ? void 0 : domRect.height);\n        r.centerInRect(_this.state.rect);\n\n        _this.dragDiv.setAttribute(\"data-layout-path\", \"/drag-rectangle\");\n\n        _this.dragDiv.style.left = r.x + \"px\";\n        _this.dragDiv.style.top = r.y + \"px\";\n      }\n    });\n    var rootdiv = this.selfRef.current;\n    rootdiv.appendChild(this.dragDiv);\n  };\n  /** @internal */\n\n\n  Layout.prototype.handleCustomTabDrag = function (dropInfo, pos, event) {\n    var _this = this;\n\n    var _a, _b, _c;\n\n    var invalidated = (_a = this.customDrop) === null || _a === void 0 ? void 0 : _a.invalidated;\n    var currentCallback = (_b = this.customDrop) === null || _b === void 0 ? void 0 : _b.callback;\n    this.customDrop = undefined;\n    var dragging = this.newTabJson || (this.dragNode instanceof TabNode_1.TabNode ? this.dragNode : undefined);\n\n    if (dragging && (dropInfo.node instanceof TabSetNode_1.TabSetNode || dropInfo.node instanceof BorderNode_1.BorderNode) && dropInfo.index === -1) {\n      var selected = dropInfo.node.getSelectedNode();\n      var tabRect = selected === null || selected === void 0 ? void 0 : selected.getRect();\n\n      if (selected && (tabRect === null || tabRect === void 0 ? void 0 : tabRect.contains(pos.x, pos.y))) {\n        var customDrop = undefined;\n\n        try {\n          var dest = this.onTabDrag(dragging, selected, pos.x - tabRect.x, pos.y - tabRect.y, dropInfo.location, function () {\n            return _this.onDragMove(event);\n          });\n\n          if (dest) {\n            customDrop = {\n              rect: new Rect_1.Rect(dest.x + tabRect.x, dest.y + tabRect.y, dest.width, dest.height),\n              callback: dest.callback,\n              invalidated: dest.invalidated,\n              dragging: dragging,\n              over: selected,\n              x: pos.x - tabRect.x,\n              y: pos.y - tabRect.y,\n              location: dropInfo.location,\n              cursor: dest.cursor\n            };\n          }\n        } catch (e) {\n          console.error(e);\n        }\n\n        if ((customDrop === null || customDrop === void 0 ? void 0 : customDrop.callback) === currentCallback) {\n          invalidated = undefined;\n        }\n\n        this.customDrop = customDrop;\n      }\n    }\n\n    this.dropInfo = dropInfo;\n    this.outlineDiv.className = this.getClassName(this.customDrop ? Types_1.CLASSES.FLEXLAYOUT__OUTLINE_RECT : dropInfo.className);\n\n    if (this.customDrop) {\n      this.customDrop.rect.positionElement(this.outlineDiv);\n    } else {\n      dropInfo.rect.positionElement(this.outlineDiv);\n    }\n\n    DragDrop_1.DragDrop.instance.setGlassCursorOverride((_c = this.customDrop) === null || _c === void 0 ? void 0 : _c.cursor);\n    this.outlineDiv.style.visibility = \"visible\";\n\n    try {\n      invalidated === null || invalidated === void 0 ? void 0 : invalidated();\n    } catch (e) {\n      console.error(e);\n    }\n  };\n  /** @internal */\n\n\n  Layout.prototype.onDragEnter = function (event) {\n    // DragDrop keeps track of number of dragenters minus the number of\n    // dragleaves. Only start a new drag if there isn't one already.\n    if (DragDrop_1.DragDrop.instance.isDragging()) return;\n    var drag = this.props.onExternalDrag(event);\n\n    if (drag) {\n      // Mimic addTabWithDragAndDrop, but pass in DragEvent\n      this.fnNewNodeDropped = drag.onDrop;\n      this.newTabJson = drag.json;\n      this.dragStart(event, drag.dragText, TabNode_1.TabNode._fromJson(drag.json, this.props.model, false), true, undefined, undefined);\n    }\n  };\n  /** @internal */\n\n\n  Layout.prototype.checkForBorderToShow = function (x, y) {\n    var r = this.props.model._getOuterInnerRects().outer;\n\n    var c = r.getCenter();\n    var margin = this.edgeRectWidth;\n    var offset = this.edgeRectLength / 2;\n    var overEdge = false;\n\n    if (this.props.model.isEnableEdgeDock() && this.state.showHiddenBorder === DockLocation_1.DockLocation.CENTER) {\n      if (y > c.y - offset && y < c.y + offset || x > c.x - offset && x < c.x + offset) {\n        overEdge = true;\n      }\n    }\n\n    var location = DockLocation_1.DockLocation.CENTER;\n\n    if (!overEdge) {\n      if (x <= r.x + margin) {\n        location = DockLocation_1.DockLocation.LEFT;\n      } else if (x >= r.getRight() - margin) {\n        location = DockLocation_1.DockLocation.RIGHT;\n      } else if (y <= r.y + margin) {\n        location = DockLocation_1.DockLocation.TOP;\n      } else if (y >= r.getBottom() - margin) {\n        location = DockLocation_1.DockLocation.BOTTOM;\n      }\n    }\n\n    if (location !== this.state.showHiddenBorder) {\n      this.setState({\n        showHiddenBorder: location\n      });\n    }\n  };\n  /** @internal */\n\n\n  Layout.prototype.showEdges = function (rootdiv) {\n    if (this.props.model.isEnableEdgeDock()) {\n      var length_1 = this.edgeRectLength + \"px\";\n      var radius = \"50px\";\n      var width = this.edgeRectWidth + \"px\";\n      this.edgeTopDiv = this.currentDocument.createElement(\"div\");\n      this.edgeTopDiv.className = this.getClassName(Types_1.CLASSES.FLEXLAYOUT__EDGE_RECT);\n      this.edgeTopDiv.style.width = length_1;\n      this.edgeTopDiv.style.height = width;\n      this.edgeTopDiv.style.borderBottomLeftRadius = radius;\n      this.edgeTopDiv.style.borderBottomRightRadius = radius;\n      this.edgeLeftDiv = this.currentDocument.createElement(\"div\");\n      this.edgeLeftDiv.className = this.getClassName(Types_1.CLASSES.FLEXLAYOUT__EDGE_RECT);\n      this.edgeLeftDiv.style.width = width;\n      this.edgeLeftDiv.style.height = length_1;\n      this.edgeLeftDiv.style.borderTopRightRadius = radius;\n      this.edgeLeftDiv.style.borderBottomRightRadius = radius;\n      this.edgeBottomDiv = this.currentDocument.createElement(\"div\");\n      this.edgeBottomDiv.className = this.getClassName(Types_1.CLASSES.FLEXLAYOUT__EDGE_RECT);\n      this.edgeBottomDiv.style.width = length_1;\n      this.edgeBottomDiv.style.height = width;\n      this.edgeBottomDiv.style.borderTopLeftRadius = radius;\n      this.edgeBottomDiv.style.borderTopRightRadius = radius;\n      this.edgeRightDiv = this.currentDocument.createElement(\"div\");\n      this.edgeRightDiv.className = this.getClassName(Types_1.CLASSES.FLEXLAYOUT__EDGE_RECT);\n      this.edgeRightDiv.style.width = width;\n      this.edgeRightDiv.style.height = length_1;\n      this.edgeRightDiv.style.borderTopLeftRadius = radius;\n      this.edgeRightDiv.style.borderBottomLeftRadius = radius;\n      this.repositionEdges(this.state.rect);\n      rootdiv.appendChild(this.edgeTopDiv);\n      rootdiv.appendChild(this.edgeLeftDiv);\n      rootdiv.appendChild(this.edgeBottomDiv);\n      rootdiv.appendChild(this.edgeRightDiv);\n      this.edgesShown = true;\n    }\n  };\n  /** @internal */\n\n\n  Layout.prototype.repositionEdges = function (domRect) {\n    if (this.props.model.isEnableEdgeDock()) {\n      var r = this.centerRect;\n      this.edgeTopDiv.style.top = r.y + \"px\";\n      this.edgeTopDiv.style.left = r.x + (r.width - this.edgeRectLength) / 2 + \"px\";\n      this.edgeLeftDiv.style.top = r.y + (r.height - this.edgeRectLength) / 2 + \"px\";\n      this.edgeLeftDiv.style.left = r.x + \"px\";\n      this.edgeBottomDiv.style.bottom = domRect.height - r.getBottom() + \"px\";\n      this.edgeBottomDiv.style.left = r.x + (r.width - this.edgeRectLength) / 2 + \"px\";\n      this.edgeRightDiv.style.top = r.y + (r.height - this.edgeRectLength) / 2 + \"px\";\n      this.edgeRightDiv.style.right = domRect.width - r.getRight() + \"px\";\n    }\n  };\n  /** @internal */\n\n\n  Layout.prototype.hideEdges = function (rootdiv) {\n    if (this.props.model.isEnableEdgeDock()) {\n      try {\n        rootdiv.removeChild(this.edgeTopDiv);\n        rootdiv.removeChild(this.edgeLeftDiv);\n        rootdiv.removeChild(this.edgeBottomDiv);\n        rootdiv.removeChild(this.edgeRightDiv);\n      } catch (e) {}\n    }\n\n    this.edgesShown = false;\n  };\n  /** @internal */\n\n\n  Layout.prototype.maximize = function (tabsetNode) {\n    this.doAction(Actions_1.Actions.maximizeToggle(tabsetNode.getId()));\n  };\n  /** @internal */\n\n\n  Layout.prototype.customizeTab = function (tabNode, renderValues) {\n    if (this.props.onRenderTab) {\n      this.props.onRenderTab(tabNode, renderValues);\n    }\n  };\n  /** @internal */\n\n\n  Layout.prototype.customizeTabSet = function (tabSetNode, renderValues) {\n    if (this.props.onRenderTabSet) {\n      this.props.onRenderTabSet(tabSetNode, renderValues);\n    }\n  };\n  /** @internal */\n\n\n  Layout.prototype.i18nName = function (id, param) {\n    var message;\n\n    if (this.props.i18nMapper) {\n      message = this.props.i18nMapper(id, param);\n    }\n\n    if (message === undefined) {\n      message = id + (param === undefined ? \"\" : param);\n    }\n\n    return message;\n  };\n  /** @internal */\n\n\n  Layout.prototype.getOnRenderFloatingTabPlaceholder = function () {\n    return this.props.onRenderFloatingTabPlaceholder;\n  };\n  /** @internal */\n\n\n  Layout.prototype.getShowOverflowMenu = function () {\n    return this.props.onShowOverflowMenu;\n  };\n  /** @internal */\n\n\n  Layout.prototype.getTabSetPlaceHolderCallback = function () {\n    return this.props.onTabSetPlaceHolder;\n  };\n  /** @internal */\n\n\n  Layout.prototype.showContextMenu = function (node, event) {\n    if (this.props.onContextMenu) {\n      this.props.onContextMenu(node, event);\n    }\n  };\n  /** @internal */\n\n\n  Layout.prototype.auxMouseClick = function (node, event) {\n    if (this.props.onAuxMouseClick) {\n      this.props.onAuxMouseClick(node, event);\n    }\n  };\n\n  return Layout;\n}(React.Component);\n\nexports.Layout = Layout;\n/** @internal */\n\nvar DragRectRenderWrapper = function (props) {\n  React.useEffect(function () {\n    var _a;\n\n    (_a = props.onRendered) === null || _a === void 0 ? void 0 : _a.call(props);\n  }, [props]);\n  return React.createElement(React.Fragment, null, props.children);\n};","map":{"version":3,"mappings":"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","names":["defaultIcons","close","React","Icons_1","closeTabset","popout","maximize","restore","more","isIEorEdge","window","document","documentMode","test","navigator","userAgent","isDesktop","matchMedia","matches","defaultSupportsPopout","__extends","props","_super","_this","undefined","forceUpdate","onModelChange","model","domRect","getDomRect","rect","Rect_1","width","height","equals","state","setState","findHeaderBarSizeRef","current","headerBarSize","getBoundingClientRect","calculatedHeaderBarSize","findTabBarSizeRef","tabBarSize","calculatedTabBarSize","findBorderBarSizeRef","borderBarSize","calculatedBorderBarSize","defaultClassName","classNameMapper","id","doAction","Actions_1","unFloatTab","getNodeById","_setWindow","e","rootdiv","selfRef","removeChild","dragDiv","hidePortal","fnNewNodeDropped","customDrop","_a","invalidated","_b","console","error","DragDrop_1","instance","hideGlass","newTabJson","wasDragging","outlineDiv","hideEdges","showHiddenBorder","DockLocation_1","CENTER","event","preventDefault","dragStart","dragDivText","TabNode_1","_fromJson","node","allowDrag","onClick","onDoubleClick","getMaximizedTabset","startDrag","currentDocument","dragNode","onDragStart","onDragMove","onDragEnd","onCancelDrag","text","json","onRendered","content","style","whiteSpace","replace","TabButtonStamp_1","layout","iconFactory","titleFactory","onRenderDragRect","customContent","visibility","dragRectRendered","showPortal","DragRectRenderWrapper","control","element","portal","ReactDOM","createPortal","dropInfo","createElement","className","getClassName","Types_1","FLEXLAYOUT__OUTLINE_RECT","appendChild","FLEXLAYOUT__DRAG_RECT","setAttribute","dragRectRender","showEdges","getTabRect","positionElement","firstMove","speed","_getAttribute","transition","concat","clientRect","pos","x","clientX","left","y","clientY","top","checkForBorderToShow","dragRect","newLeft","Math","max","_findDropTargetNode","onTabDrag","handleCustomTabDrag","callback","dragging","over","location_1","newNode","addNode","getId","location","index","moveNode","_setChangeListener","tabIds","createRef","supportsPopout","popoutURL","icons","__assign","firstRender","editingTab","onDragEnter","bind","Layout","font","size","setProperty","family","fontStyle","weight","fontWeight","action","onAction","outcome","updateRect","updateLayoutMetrics","ownerDocument","currentWindow","defaultView","resizeObserver","ResizeObserver","entries","contentRect","observe","previousModel","realtimeResize","args","unobserve","tabNode","ref","FLEXLAYOUT__LAYOUT","metricsElements","_setPointerFine","borderComponents","tabSetComponents","floatingWindows","tabComponents","splitterComponents","metrics","_setShowHiddenBorder","centerRect","_layout","renderBorder","getBorderSet","renderChildren","getRoot","edgesShown","repositionEdges","nextTopIds","nextTopIdsMap","_i","t","push","keys","onExternalDrag","map","styleFont","Fragment","key","FLEXLAYOUT__TABSET_HEADER_SIZER","FLEXLAYOUT__TABSET_SIZER","FLEXLAYOUT__BORDER_SIZER","borderSet","getBorders","border","borderPath","getLocation","getName","isShowing","BorderTabSet_1","path","drawChildren","_getDrawChildren","i","tabCount","child","SplitterNode_1","Splitter_1","isFloating","_getScreenRect","FloatingWindow_1","url","title","onSetWindow","onCloseWindow","FloatingWindowTab_1","factory","TabFloating_1","selected","getSelected","Tab_1","splitterCount","rowCount","newPath","TabSetNode_1","TabSet_1","selectedTab","getParent","getChildren","warn","getOrientation","Orientation_1","HORZ","getRect","clone","bodyRect","navHeight","min","outerHeight","innerHeight","navWidth","outerWidth","innerWidth","screenX","screenY","tabsetId","tabsetNode","getActiveTabset","dragText","onDrop","addGlass","onCancelAdd","addEventListener","onDragDivMouseDown","r","centerInRect","currentCallback","BorderNode_1","getSelectedNode","tabRect","contains","dest","cursor","setGlassCursorOverride","_c","isDragging","drag","_getOuterInnerRects","outer","c","getCenter","margin","edgeRectWidth","offset","edgeRectLength","overEdge","isEnableEdgeDock","LEFT","getRight","RIGHT","TOP","getBottom","BOTTOM","length_1","radius","edgeTopDiv","FLEXLAYOUT__EDGE_RECT","borderBottomLeftRadius","borderBottomRightRadius","edgeLeftDiv","borderTopRightRadius","edgeBottomDiv","borderTopLeftRadius","edgeRightDiv","bottom","right","maximizeToggle","renderValues","onRenderTab","tabSetNode","onRenderTabSet","param","message","i18nMapper","onRenderFloatingTabPlaceholder","onShowOverflowMenu","onTabSetPlaceHolder","onContextMenu","onAuxMouseClick","Component","exports","useEffect","children"],"sources":["C:\\Users\\mmorrone\\UnityProjects\\my-app\\node_modules\\flexlayout-react\\src\\view\\Layout.tsx"],"sourcesContent":["import * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nimport { DockLocation } from \"../DockLocation\";\nimport { DragDrop } from \"../DragDrop\";\nimport { DropInfo } from \"../DropInfo\";\nimport { I18nLabel } from \"../I18nLabel\";\nimport { Action } from \"../model/Action\";\nimport { Actions } from \"../model/Actions\";\nimport { BorderNode } from \"../model/BorderNode\";\nimport { BorderSet } from \"../model/BorderSet\";\nimport { IDraggable } from \"../model/IDraggable\";\nimport { Model, ILayoutMetrics } from \"../model/Model\";\nimport { Node } from \"../model/Node\";\nimport { RowNode } from \"../model/RowNode\";\nimport { SplitterNode } from \"../model/SplitterNode\";\nimport { TabNode } from \"../model/TabNode\";\nimport { TabSetNode } from \"../model/TabSetNode\";\nimport { Rect } from \"../Rect\";\nimport { CLASSES } from \"../Types\";\nimport { BorderTabSet } from \"./BorderTabSet\";\nimport { Splitter } from \"./Splitter\";\nimport { Tab } from \"./Tab\";\nimport { TabSet } from \"./TabSet\";\nimport { FloatingWindow } from \"./FloatingWindow\";\nimport { FloatingWindowTab } from \"./FloatingWindowTab\";\nimport { TabFloating } from \"./TabFloating\";\nimport { IJsonTabNode } from \"../model/IJsonModel\";\nimport { Orientation } from \"../Orientation\";\nimport { CloseIcon, MaximizeIcon, OverflowIcon, PopoutIcon, RestoreIcon } from \"./Icons\";\nimport { TabButtonStamp } from \"./TabButtonStamp\";\n\nexport type CustomDragCallback = (dragging: TabNode | IJsonTabNode, over: TabNode, x: number, y: number, location: DockLocation) => void;\nexport type DragRectRenderCallback = (content: React.ReactElement | undefined, node?: Node, json?: IJsonTabNode) => React.ReactElement | undefined;\nexport type FloatingTabPlaceholderRenderCallback = (dockPopout: () => void, showPopout: () => void) => React.ReactElement | undefined;\nexport type NodeMouseEvent = (node: TabNode | TabSetNode | BorderNode, event: React.MouseEvent<HTMLElement, MouseEvent>) => void;\nexport type ShowOverflowMenuCallback = (\n    node: TabSetNode | BorderNode,\n    mouseEvent: React.MouseEvent<HTMLElement, MouseEvent>,\n    items: { index: number; node: TabNode }[],\n    onSelect: (item: { index: number; node: TabNode }) => void,\n) => void;\nexport type TabSetPlaceHolderCallback = (node: TabSetNode) => React.ReactNode;\n\nexport interface ILayoutProps {\n    model: Model;\n    factory: (node: TabNode) => React.ReactNode;\n    font?: IFontValues;\n    fontFamily?: string;\n    iconFactory?: (node: TabNode) => React.ReactNode | undefined;\n    titleFactory?: (node: TabNode) => ITitleObject | React.ReactNode | undefined;\n    icons?: IIcons;\n    onAction?: (action: Action) => Action | undefined;\n    onRenderTab?: (\n        node: TabNode,\n        renderValues: ITabRenderValues, // change the values in this object as required\n    ) => void;\n    onRenderTabSet?: (\n        tabSetNode: TabSetNode | BorderNode,\n        renderValues: ITabSetRenderValues, // change the values in this object as required\n    ) => void;\n    onModelChange?: (model: Model) => void;\n    onExternalDrag?: (event: React.DragEvent<HTMLDivElement>) => undefined | {\n        dragText: string,\n        json: any,\n        onDrop?: (node?: Node, event?: Event) => void\n    };\n    classNameMapper?: (defaultClassName: string) => string;\n    i18nMapper?: (id: I18nLabel, param?: string) => string | undefined;\n    supportsPopout?: boolean | undefined;\n    popoutURL?: string | undefined;\n    realtimeResize?: boolean | undefined;\n    onTabDrag?: (dragging: TabNode | IJsonTabNode, over: TabNode, x: number, y: number, location: DockLocation, refresh: () => void) => undefined | {\n        x: number,\n        y: number,\n        width: number,\n        height: number,\n        callback: CustomDragCallback,\n        // Called once when `callback` is not going to be called anymore (user canceled the drag, moved mouse and you returned a different callback, etc)\n        invalidated?: () => void,\n        cursor?: string | undefined\n    };\n    onRenderDragRect?: DragRectRenderCallback;\n    onRenderFloatingTabPlaceholder?: FloatingTabPlaceholderRenderCallback;\n    onContextMenu?: NodeMouseEvent;\n    onAuxMouseClick?: NodeMouseEvent;\n    onShowOverflowMenu?: ShowOverflowMenuCallback;\n    onTabSetPlaceHolder?: TabSetPlaceHolderCallback;\n}\nexport interface IFontValues {\n    size?: string;\n    family?: string;\n    style?: string;\n    weight?: string;\n}\n\nexport interface ITabSetRenderValues {\n    headerContent?: React.ReactNode;\n    centerContent?: React.ReactNode;\n    stickyButtons: React.ReactNode[];\n    buttons: React.ReactNode[];\n    headerButtons: React.ReactNode[];\n}\n\nexport interface ITabRenderValues {\n    leading: React.ReactNode;\n    content: React.ReactNode;\n    name: string;\n    buttons: React.ReactNode[];\n}\n\nexport interface ITitleObject {\n    titleContent: React.ReactNode;\n    name: string;\n}\n\nexport interface ILayoutState {\n    rect: Rect;\n    calculatedHeaderBarSize: number;\n    calculatedTabBarSize: number;\n    calculatedBorderBarSize: number;\n    editingTab?: TabNode;\n    showHiddenBorder: DockLocation;\n    portal?: React.ReactNode;\n}\n\nexport interface IIcons {\n    close?: (React.ReactNode | ((tabNode: TabNode) => React.ReactNode));\n    closeTabset?: (React.ReactNode | ((tabSetNode: TabSetNode) => React.ReactNode));\n    popout?: (React.ReactNode | ((tabNode: TabNode) => React.ReactNode));\n    maximize?: (React.ReactNode | ((tabSetNode: TabSetNode) => React.ReactNode));\n    restore?: (React.ReactNode | ((tabSetNode: TabSetNode) => React.ReactNode));\n    more?: (React.ReactNode | ((tabSetNode: (TabSetNode | BorderNode), hiddenTabs: { node: TabNode; index: number }[]) => React.ReactNode));\n}\n\nconst defaultIcons = {\n    close: <CloseIcon />,\n    closeTabset: <CloseIcon />,\n    popout: <PopoutIcon />,\n    maximize: <MaximizeIcon />,\n    restore: <RestoreIcon />,\n    more: <OverflowIcon />,\n};\n\nexport interface ICustomDropDestination {\n    rect: Rect;\n    callback: CustomDragCallback;\n    invalidated: (() => void) | undefined;\n    dragging: TabNode | IJsonTabNode;\n    over: TabNode;\n    x: number;\n    y: number;\n    location: DockLocation;\n    cursor: string | undefined;\n}\n\n/** @internal */\nexport interface ILayoutCallbacks {\n    i18nName(id: I18nLabel, param?: string): string;\n    maximize(tabsetNode: TabSetNode): void;\n    getPopoutURL(): string;\n    isSupportsPopout(): boolean;\n    isRealtimeResize(): boolean;\n    getCurrentDocument(): HTMLDocument | undefined;\n    getClassName(defaultClassName: string): string;\n    doAction(action: Action): Node | undefined;\n    getDomRect(): any;\n    getRootDiv(): HTMLDivElement;\n    dragStart(\n        event: Event | React.MouseEvent<HTMLDivElement, MouseEvent> | React.TouchEvent<HTMLDivElement> | React.DragEvent<HTMLDivElement> | undefined,\n        dragDivText: string | undefined,\n        node: Node & IDraggable,\n        allowDrag: boolean,\n        onClick?: (event: Event) => void,\n        onDoubleClick?: (event: Event) => void\n    ): void;\n    customizeTab(\n        tabNode: TabNode,\n        renderValues: ITabRenderValues,\n    ): void;\n    customizeTabSet(\n        tabSetNode: TabSetNode | BorderNode,\n        renderValues: ITabSetRenderValues,\n    ): void;\n    styleFont: (style: Record<string, string>) => Record<string, string>;\n    setEditingTab(tabNode?: TabNode): void;\n    getEditingTab(): TabNode | undefined;\n    getOnRenderFloatingTabPlaceholder(): FloatingTabPlaceholderRenderCallback | undefined;\n    showContextMenu(node: TabNode | TabSetNode | BorderNode, event: React.MouseEvent<HTMLElement, MouseEvent>): void;\n    auxMouseClick(node: TabNode | TabSetNode | BorderNode, event: React.MouseEvent<HTMLElement, MouseEvent>): void;\n    showPortal: (portal: React.ReactNode, portalDiv: HTMLDivElement) => void;\n    hidePortal: () => void;\n    getShowOverflowMenu(): ShowOverflowMenuCallback | undefined;\n    getTabSetPlaceHolderCallback() : TabSetPlaceHolderCallback | undefined;\n}\n\n// Popout windows work in latest browsers based on webkit (Chrome, Opera, Safari, latest Edge) and Firefox. They do\n// not work on any version if IE or the original Edge browser\n// Assume any recent desktop browser not IE or original Edge will work\n/** @internal */\n// @ts-ignore\nconst isIEorEdge = typeof window !== \"undefined\" && (window.document.documentMode || /Edge\\//.test(window.navigator.userAgent));\n/** @internal */\nconst isDesktop = typeof window !== \"undefined\" && window.matchMedia && window.matchMedia(\"(hover: hover) and (pointer: fine)\").matches;\n/** @internal */\nconst defaultSupportsPopout: boolean = isDesktop && !isIEorEdge;\n\n/**\n * A React component that hosts a multi-tabbed layout\n */\nexport class Layout extends React.Component<ILayoutProps, ILayoutState> {\n\n    /** @internal */\n    private selfRef: React.RefObject<HTMLDivElement>;\n    /** @internal */\n    private findHeaderBarSizeRef: React.RefObject<HTMLDivElement>;\n    /** @internal */\n    private findTabBarSizeRef: React.RefObject<HTMLDivElement>;\n    /** @internal */\n    private findBorderBarSizeRef: React.RefObject<HTMLDivElement>;\n    /** @internal */\n    private previousModel?: Model;\n    /** @internal */\n    private centerRect?: Rect;\n\n    /** @internal */\n    // private start: number = 0;\n    /** @internal */\n    // private layoutTime: number = 0;\n\n    /** @internal */\n    private tabIds: string[];\n    /** @internal */\n    private newTabJson: IJsonTabNode | undefined;\n    /** @internal */\n    private firstMove: boolean = false;\n    /** @internal */\n    private dragNode?: Node & IDraggable;\n    /** @internal */\n    private dragDiv?: HTMLDivElement;\n    /** @internal */\n    private dragRectRendered: boolean = true;\n    /** @internal */\n    private dragDivText: string | undefined = undefined;\n    /** @internal */\n    private dropInfo: DropInfo | undefined;\n    /** @internal */\n    private customDrop: ICustomDropDestination | undefined;\n    /** @internal */\n    private outlineDiv?: HTMLDivElement;\n\n    /** @internal */\n    private edgeRectLength = 100;\n    /** @internal */\n    private edgeRectWidth = 10;\n    /** @internal */\n    private edgesShown = false;\n    /** @internal */\n    private edgeRightDiv?: HTMLDivElement;\n    /** @internal */\n    private edgeBottomDiv?: HTMLDivElement;\n    /** @internal */\n    private edgeLeftDiv?: HTMLDivElement;\n    /** @internal */\n    private edgeTopDiv?: HTMLDivElement;\n    /** @internal */\n    private fnNewNodeDropped?: (node?: Node, event?: Event) => void;\n    /** @internal */\n    private currentDocument?: HTMLDocument;\n    /** @internal */\n    private currentWindow?: Window;\n    /** @internal */\n    private supportsPopout: boolean;\n    /** @internal */\n    private popoutURL: string;\n    /** @internal */\n    private icons: IIcons;\n    /** @internal */\n    private firstRender: boolean;\n    /** @internal */\n    private resizeObserver?: ResizeObserver;\n\n    constructor(props: ILayoutProps) {\n        super(props);\n        this.props.model._setChangeListener(this.onModelChange);\n        this.tabIds = [];\n        this.selfRef = React.createRef<HTMLDivElement>();\n        this.findHeaderBarSizeRef = React.createRef<HTMLDivElement>();\n        this.findTabBarSizeRef = React.createRef<HTMLDivElement>();\n        this.findBorderBarSizeRef = React.createRef<HTMLDivElement>();\n        this.supportsPopout = props.supportsPopout !== undefined ? props.supportsPopout : defaultSupportsPopout;\n        this.popoutURL = props.popoutURL ? props.popoutURL : \"popout.html\";\n        this.icons = { ...defaultIcons, ...props.icons };\n        this.firstRender = true;\n\n        this.state = {\n            rect: new Rect(0, 0, 0, 0),\n            calculatedHeaderBarSize: 25,\n            calculatedTabBarSize: 26,\n            calculatedBorderBarSize: 30,\n            editingTab: undefined,\n            showHiddenBorder: DockLocation.CENTER,\n        };\n\n        this.onDragEnter = this.onDragEnter.bind(this);\n    }\n\n    /** @internal */\n    styleFont(style: Record<string, string>): Record<string, string> {\n        if (this.props.font) {\n            if (this.selfRef.current) {\n                if (this.props.font.size) {\n                    this.selfRef.current.style.setProperty(\"--font-size\", this.props.font.size);\n                }\n                if (this.props.font.family) {\n                    this.selfRef.current.style.setProperty(\"--font-family\", this.props.font.family);\n                }\n            }\n            if (this.props.font.style) {\n                style.fontStyle = this.props.font.style;\n            }\n            if (this.props.font.weight) {\n                style.fontWeight = this.props.font.weight;\n            }\n        }\n        return style;\n    }\n\n    /** @internal */\n    onModelChange = () => {\n        this.forceUpdate();\n        if (this.props.onModelChange) {\n            this.props.onModelChange(this.props.model);\n        }\n    };\n\n    /** @internal */\n    doAction(action: Action): Node | undefined {\n        if (this.props.onAction !== undefined) {\n            const outcome = this.props.onAction(action);\n            if (outcome !== undefined) {\n                return this.props.model.doAction(outcome);\n            }\n            return undefined;\n        } else {\n            return this.props.model.doAction(action);\n        }\n    }\n\n    /** @internal */\n    componentDidMount() {\n        this.updateRect();\n        this.updateLayoutMetrics();\n\n        // need to re-render if size changes\n        this.currentDocument = (this.selfRef.current as HTMLDivElement).ownerDocument;\n        this.currentWindow = this.currentDocument.defaultView!;\n        this.resizeObserver = new ResizeObserver(entries => {\n            this.updateRect(entries[0].contentRect);\n        });\n        this.resizeObserver.observe(this.selfRef.current!);\n    }\n\n    /** @internal */\n    componentDidUpdate() {\n        this.updateLayoutMetrics();\n        if (this.props.model !== this.previousModel) {\n            if (this.previousModel !== undefined) {\n                this.previousModel._setChangeListener(undefined); // stop listening to old model\n            }\n            this.props.model._setChangeListener(this.onModelChange);\n            this.previousModel = this.props.model;\n        }\n        // console.log(\"Layout time: \" + this.layoutTime + \"ms Render time: \" + (Date.now() - this.start) + \"ms\");\n    }\n\n    /** @internal */\n    updateRect = (domRect: DOMRectReadOnly = this.getDomRect()) => {\n        const rect = new Rect(0, 0, domRect.width, domRect.height);\n        if (!rect.equals(this.state.rect) && rect.width !== 0 && rect.height !== 0) {\n            this.setState({ rect });\n        }\n    };\n\n    /** @internal */\n    updateLayoutMetrics = () => {\n        if (this.findHeaderBarSizeRef.current) {\n            const headerBarSize = this.findHeaderBarSizeRef.current.getBoundingClientRect().height;\n            if (headerBarSize !== this.state.calculatedHeaderBarSize) {\n                this.setState({ calculatedHeaderBarSize: headerBarSize });\n            }\n        }\n        if (this.findTabBarSizeRef.current) {\n            const tabBarSize = this.findTabBarSizeRef.current.getBoundingClientRect().height;\n            if (tabBarSize !== this.state.calculatedTabBarSize) {\n                this.setState({ calculatedTabBarSize: tabBarSize });\n            }\n        }\n        if (this.findBorderBarSizeRef.current) {\n            const borderBarSize = this.findBorderBarSizeRef.current.getBoundingClientRect().height;\n            if (borderBarSize !== this.state.calculatedBorderBarSize) {\n                this.setState({ calculatedBorderBarSize: borderBarSize });\n            }\n        }\n    };\n\n    /** @internal */\n    getClassName = (defaultClassName: string) => {\n        if (this.props.classNameMapper === undefined) {\n            return defaultClassName;\n        } else {\n            return this.props.classNameMapper(defaultClassName);\n        }\n    };\n\n    /** @internal */\n    getCurrentDocument() {\n        return this.currentDocument;\n    }\n\n    /** @internal */\n    getDomRect() {\n        return this.selfRef.current!.getBoundingClientRect();\n    }\n\n    /** @internal */\n    getRootDiv() {\n        return this.selfRef.current!;\n    }\n\n    /** @internal */\n    isSupportsPopout() {\n        return this.supportsPopout;\n    }\n\n    /** @internal */\n    isRealtimeResize() {\n        return this.props.realtimeResize ?? false;\n    }\n\n    /** @internal */\n    onTabDrag(...args: Parameters<Required<ILayoutProps>['onTabDrag']>) {\n        return this.props.onTabDrag?.(...args);\n    }\n\n    /** @internal */\n    getPopoutURL() {\n        return this.popoutURL;\n    }\n\n    /** @internal */\n    componentWillUnmount() {\n        this.resizeObserver?.unobserve(this.selfRef.current!)\n    }\n\n    /** @internal */\n    setEditingTab(tabNode?: TabNode) {\n        this.setState({ editingTab: tabNode });\n    }\n\n    /** @internal */\n    getEditingTab() {\n        return this.state.editingTab;\n    }\n\n    /** @internal */\n    render() {\n        // first render will be used to find the size (via selfRef)\n        if (this.firstRender) {\n            this.firstRender = false;\n            return (\n                <div ref={this.selfRef} className={this.getClassName(CLASSES.FLEXLAYOUT__LAYOUT)}>\n                    {this.metricsElements()}\n                </div>\n            );\n        }\n\n        this.props.model._setPointerFine(window && window.matchMedia && window.matchMedia(\"(pointer: fine)\").matches);\n        // this.start = Date.now();\n        const borderComponents: React.ReactNode[] = [];\n        const tabSetComponents: React.ReactNode[] = [];\n        const floatingWindows: React.ReactNode[] = [];\n        const tabComponents: Record<string, React.ReactNode> = {};\n        const splitterComponents: React.ReactNode[] = [];\n\n        const metrics: ILayoutMetrics = {\n            headerBarSize: this.state.calculatedHeaderBarSize,\n            tabBarSize: this.state.calculatedTabBarSize,\n            borderBarSize: this.state.calculatedBorderBarSize\n        };\n        this.props.model._setShowHiddenBorder(this.state.showHiddenBorder);\n\n        this.centerRect = this.props.model._layout(this.state.rect, metrics);\n\n        this.renderBorder(this.props.model.getBorderSet(), borderComponents, tabComponents, floatingWindows, splitterComponents);\n        this.renderChildren(\"\", this.props.model.getRoot(), tabSetComponents, tabComponents, floatingWindows, splitterComponents);\n\n        if (this.edgesShown) {\n            this.repositionEdges(this.state.rect)\n        }\n\n        const nextTopIds: string[] = [];\n        const nextTopIdsMap: Record<string, string> = {};\n\n        // Keep any previous tabs in the same DOM order as before, removing any that have been deleted\n        for (const t of this.tabIds) {\n            if (tabComponents[t]) {\n                nextTopIds.push(t);\n                nextTopIdsMap[t] = t;\n            }\n        }\n        this.tabIds = nextTopIds;\n\n        // Add tabs that have been added to the DOM\n        for (const t of Object.keys(tabComponents)) {\n            if (!nextTopIdsMap[t]) {\n                this.tabIds.push(t);\n            }\n        }\n\n        // this.layoutTime = (Date.now() - this.start);\n\n        return (\n            <div ref={this.selfRef} className={this.getClassName(CLASSES.FLEXLAYOUT__LAYOUT)} onDragEnter={this.props.onExternalDrag ? this.onDragEnter : undefined}>\n                {tabSetComponents}\n                {this.tabIds.map((t) => {\n                    return tabComponents[t];\n                })}\n                {borderComponents}\n                {splitterComponents}\n                {floatingWindows}\n                {this.metricsElements()}\n                {this.state.portal}\n            </div>\n        );\n    }\n\n    /** @internal */\n    metricsElements() {\n        // used to measure the tab and border tab sizes\n        const fontStyle = this.styleFont({ visibility: \"hidden\" });\n        return (\n            <React.Fragment>\n                <div key=\"findHeaderBarSize\" ref={this.findHeaderBarSizeRef} style={fontStyle} className={this.getClassName(CLASSES.FLEXLAYOUT__TABSET_HEADER_SIZER)}>\n                    FindHeaderBarSize\n                </div>\n                <div key=\"findTabBarSize\" ref={this.findTabBarSizeRef} style={fontStyle} className={this.getClassName(CLASSES.FLEXLAYOUT__TABSET_SIZER)}>\n                    FindTabBarSize\n                </div>\n                <div key=\"findBorderBarSize\" ref={this.findBorderBarSizeRef} style={fontStyle} className={this.getClassName(CLASSES.FLEXLAYOUT__BORDER_SIZER)}>\n                    FindBorderBarSize\n                </div>\n            </React.Fragment>\n        );\n    }\n\n    /** @internal */\n    onCloseWindow = (id: string) => {\n        this.doAction(Actions.unFloatTab(id));\n        try {\n            (this.props.model.getNodeById(id) as TabNode)._setWindow(undefined);\n        } catch (e) {\n            // catch incase it was a model change\n        }\n    };\n\n    /** @internal */\n    onSetWindow = (id: string, window: Window) => {\n        (this.props.model.getNodeById(id) as TabNode)._setWindow(window);\n    };\n\n    /** @internal */\n    renderBorder(borderSet: BorderSet, borderComponents: React.ReactNode[], tabComponents: Record<string, React.ReactNode>, floatingWindows: React.ReactNode[], splitterComponents: React.ReactNode[]) {\n        for (const border of borderSet.getBorders()) {\n            const borderPath = `/border/${border.getLocation().getName()}`;\n            if (border.isShowing()) {\n                borderComponents.push(\n                    <BorderTabSet\n                        key={`border_${border.getLocation().getName()}`}\n                        path={borderPath}\n                        border={border}\n                        layout={this}\n                        iconFactory={this.props.iconFactory}\n                        titleFactory={this.props.titleFactory}\n                        icons={this.icons}\n                    />\n                );\n                const drawChildren = border._getDrawChildren();\n                let i = 0;\n                let tabCount = 0;\n                for (const child of drawChildren) {\n                    if (child instanceof SplitterNode) {\n                        let path = borderPath + \"/s\";\n                        splitterComponents.push(<Splitter key={child.getId()} layout={this} node={child} path={path} />);\n                    } else if (child instanceof TabNode) {\n                        let path = borderPath + \"/t\" + tabCount++;\n                        if (this.supportsPopout && child.isFloating()) {\n                            const rect = this._getScreenRect(child);\n                            floatingWindows.push(\n                                <FloatingWindow\n                                    key={child.getId()}\n                                    url={this.popoutURL}\n                                    rect={rect}\n                                    title={child.getName()}\n                                    id={child.getId()}\n                                    onSetWindow={this.onSetWindow}\n                                    onCloseWindow={this.onCloseWindow}\n                                >\n                                    <FloatingWindowTab layout={this} node={child} factory={this.props.factory} />\n                                </FloatingWindow>\n                            );\n                            tabComponents[child.getId()] = <TabFloating key={child.getId()}\n                                layout={this}\n                                path={path}\n                                node={child}\n                                selected={i === border.getSelected()\n                                } />;\n                        } else {\n                            tabComponents[child.getId()] = <Tab key={child.getId()}\n                                layout={this}\n                                path={path}\n                                node={child}\n                                selected={i === border.getSelected()}\n                                factory={this.props.factory} />;\n                        }\n                    }\n                    i++;\n                }\n            }\n        }\n    }\n\n    /** @internal */\n    renderChildren(path: string, node: RowNode | TabSetNode, tabSetComponents: React.ReactNode[], tabComponents: Record<string, React.ReactNode>, floatingWindows: React.ReactNode[], splitterComponents: React.ReactNode[]) {\n        const drawChildren = node._getDrawChildren();\n        let splitterCount = 0;\n        let tabCount = 0;\n        let rowCount = 0;\n\n        for (const child of drawChildren!) {\n            if (child instanceof SplitterNode) {\n                const newPath = path + \"/s\" + (splitterCount++);\n                splitterComponents.push(<Splitter key={child.getId()} layout={this} path={newPath} node={child} />);\n            } else if (child instanceof TabSetNode) {\n                const newPath = path + \"/ts\" + (rowCount++);\n                tabSetComponents.push(<TabSet key={child.getId()} layout={this} path={newPath} node={child} iconFactory={this.props.iconFactory} titleFactory={this.props.titleFactory} icons={this.icons} />);\n                this.renderChildren(newPath, child, tabSetComponents, tabComponents, floatingWindows, splitterComponents);\n            } else if (child instanceof TabNode) {\n                const newPath = path + \"/t\" + (tabCount++);\n                const selectedTab = child.getParent()!.getChildren()[(child.getParent() as TabSetNode).getSelected()];\n                if (selectedTab === undefined) {\n                    // this should not happen!\n                    console.warn(\"undefined selectedTab should not happen\");\n                }\n                if (this.supportsPopout && child.isFloating()) {\n                    const rect = this._getScreenRect(child);\n                    floatingWindows.push(\n                        <FloatingWindow\n                            key={child.getId()}\n                            url={this.popoutURL}\n                            rect={rect}\n                            title={child.getName()}\n                            id={child.getId()}\n                            onSetWindow={this.onSetWindow}\n                            onCloseWindow={this.onCloseWindow}\n                        >\n                            <FloatingWindowTab layout={this} node={child} factory={this.props.factory} />\n                        </FloatingWindow>\n                    );\n                    tabComponents[child.getId()] = <TabFloating key={child.getId()} layout={this} path={newPath} node={child} selected={child === selectedTab} />;\n                } else {\n                    tabComponents[child.getId()] = <Tab key={child.getId()} layout={this} path={newPath} node={child} selected={child === selectedTab} factory={this.props.factory} />;\n                }\n            } else {\n                // is row\n                const newPath = path + ((child.getOrientation() === Orientation.HORZ) ? \"/r\" : \"/c\") + (rowCount++);\n                this.renderChildren(newPath, child as RowNode, tabSetComponents, tabComponents, floatingWindows, splitterComponents);\n            }\n        }\n    }\n\n    /** @internal */\n    _getScreenRect(node: TabNode) {\n        const rect = node!.getRect()!.clone();\n        const bodyRect: DOMRect = this.selfRef.current!.getBoundingClientRect();\n        const navHeight = Math.min(80, this.currentWindow!.outerHeight - this.currentWindow!.innerHeight);\n        const navWidth = Math.min(80, this.currentWindow!.outerWidth - this.currentWindow!.innerWidth);\n        rect.x = rect.x + bodyRect.x + this.currentWindow!.screenX + navWidth;\n        rect.y = rect.y + bodyRect.y + this.currentWindow!.screenY + navHeight;\n        return rect;\n    }\n\n    /**\n     * Adds a new tab to the given tabset\n     * @param tabsetId the id of the tabset where the new tab will be added\n     * @param json the json for the new tab node\n     */\n    addTabToTabSet(tabsetId: string, json: IJsonTabNode) {\n        const tabsetNode = this.props.model.getNodeById(tabsetId);\n        if (tabsetNode !== undefined) {\n            this.doAction(Actions.addNode(json, tabsetId, DockLocation.CENTER, -1));\n        }\n    }\n\n    /**\n     * Adds a new tab to the active tabset (if there is one)\n     * @param json the json for the new tab node\n     */\n    addTabToActiveTabSet(json: IJsonTabNode) {\n        const tabsetNode = this.props.model.getActiveTabset();\n        if (tabsetNode !== undefined) {\n            this.doAction(Actions.addNode(json, tabsetNode.getId(), DockLocation.CENTER, -1));\n        }\n    }\n\n    /**\n     * Adds a new tab by dragging a labeled panel to the drop location, dragging starts immediatelly\n     * @param dragText the text to show on the drag panel\n     * @param json the json for the new tab node\n     * @param onDrop a callback to call when the drag is complete (node and event will be undefined if the drag was cancelled)\n     */\n    addTabWithDragAndDrop(dragText: string | undefined, json: IJsonTabNode, onDrop?: (node?: Node, event?: Event) => void) {\n        this.fnNewNodeDropped = onDrop;\n        this.newTabJson = json;\n        this.dragStart(undefined, dragText, TabNode._fromJson(json, this.props.model, false), true, undefined, undefined);\n    }\n\n    /**\n     * Adds a new tab by dragging a labeled panel to the drop location, dragging starts when you\n     * mouse down on the panel\n     *\n     * @param dragText the text to show on the drag panel\n     * @param json the json for the new tab node\n     * @param onDrop a callback to call when the drag is complete (node and event will be undefined if the drag was cancelled)\n     */\n    addTabWithDragAndDropIndirect(dragText: string | undefined, json: IJsonTabNode, onDrop?: (node?: Node, event?: Event) => void) {\n        this.fnNewNodeDropped = onDrop;\n        this.newTabJson = json;\n\n        DragDrop.instance.addGlass(this.onCancelAdd);\n\n        this.dragDivText = dragText;\n        this.dragDiv = this.currentDocument!.createElement(\"div\");\n        this.dragDiv.className = this.getClassName(CLASSES.FLEXLAYOUT__DRAG_RECT);\n        this.dragDiv.addEventListener(\"mousedown\", this.onDragDivMouseDown);\n        this.dragDiv.addEventListener(\"touchstart\", this.onDragDivMouseDown);\n\n        this.dragRectRender(this.dragDivText, undefined, this.newTabJson, () => {\n            if (this.dragDiv) {\n                // now it's been rendered into the dom it can be centered\n                this.dragDiv.style.visibility = \"visible\";\n                const domRect = this.dragDiv.getBoundingClientRect();\n                const r = new Rect(0, 0, domRect?.width, domRect?.height);\n                r.centerInRect(this.state.rect);\n                this.dragDiv.setAttribute(\"data-layout-path\", \"/drag-rectangle\");\n                this.dragDiv.style.left = r.x + \"px\";\n                this.dragDiv.style.top = r.y + \"px\";\n            }\n        });\n\n        const rootdiv = this.selfRef.current;\n        rootdiv!.appendChild(this.dragDiv);\n    }\n\n    /** @internal */\n    onCancelAdd = () => {\n        const rootdiv = this.selfRef.current;\n        rootdiv!.removeChild(this.dragDiv!);\n        this.dragDiv = undefined;\n        this.hidePortal();\n        if (this.fnNewNodeDropped != null) {\n            this.fnNewNodeDropped();\n            this.fnNewNodeDropped = undefined;\n        }\n\n        try {\n            this.customDrop?.invalidated?.()\n        } catch (e) {\n            console.error(e)\n        }\n\n        DragDrop.instance.hideGlass();\n        this.newTabJson = undefined;\n        this.customDrop = undefined;\n    };\n\n    /** @internal */\n    onCancelDrag = (wasDragging: boolean) => {\n        if (wasDragging) {\n            const rootdiv = this.selfRef.current!;\n\n            try {\n                rootdiv.removeChild(this.outlineDiv!);\n            } catch (e) { }\n\n            try {\n                rootdiv.removeChild(this.dragDiv!);\n            } catch (e) { }\n\n            this.dragDiv = undefined;\n            this.hidePortal();\n            this.hideEdges(rootdiv);\n            if (this.fnNewNodeDropped != null) {\n                this.fnNewNodeDropped();\n                this.fnNewNodeDropped = undefined;\n            }\n\n            try {\n                this.customDrop?.invalidated?.()\n            } catch (e) {\n                console.error(e)\n            }\n\n            DragDrop.instance.hideGlass();\n            this.newTabJson = undefined;\n            this.customDrop = undefined;\n        }\n        this.setState({ showHiddenBorder: DockLocation.CENTER });\n\n    };\n\n    /** @internal */\n    onDragDivMouseDown = (event: Event) => {\n        event.preventDefault();\n        this.dragStart(event, this.dragDivText, TabNode._fromJson(this.newTabJson, this.props.model, false), true, undefined, undefined);\n    };\n\n    /** @internal */\n    dragStart = (\n        event: Event | React.MouseEvent<HTMLDivElement, MouseEvent> | React.TouchEvent<HTMLDivElement> | React.DragEvent<HTMLDivElement> | undefined,\n        dragDivText: string | undefined,\n        node: Node & IDraggable,\n        allowDrag: boolean,\n        onClick?: (event: Event) => void,\n        onDoubleClick?: (event: Event) => void\n    ) => {\n        if (this.props.model.getMaximizedTabset() !== undefined || !allowDrag) {\n            DragDrop.instance.startDrag(event, undefined, undefined, undefined, undefined, onClick, onDoubleClick, this.currentDocument, this.selfRef.current!);\n        } else {\n            this.dragNode = node;\n            this.dragDivText = dragDivText;\n            DragDrop.instance.startDrag(event, this.onDragStart, this.onDragMove, this.onDragEnd, this.onCancelDrag, onClick, onDoubleClick, this.currentDocument, this.selfRef.current!);\n        }\n    };\n\n    /** @internal */\n    dragRectRender = (text: String | undefined, node?: Node, json?: IJsonTabNode, onRendered?: () => void) => {\n        let content: React.ReactElement | undefined;\n\n        if (text !== undefined) {\n            content = <div style={{ whiteSpace: \"pre\" }}>{text.replace(\"<br>\", \"\\n\")}</div>;\n        } else {\n            if (node && node instanceof TabNode) {\n                content = (<TabButtonStamp\n                    node={node}\n                    layout={this}\n                    iconFactory={this.props.iconFactory}\n                    titleFactory={this.props.titleFactory}\n                />);\n            }\n        }\n\n        if (this.props.onRenderDragRect !== undefined) {\n            const customContent = this.props.onRenderDragRect(content, node, json);\n            if (customContent !== undefined) {\n                content = customContent;\n            }\n        }\n\n        // hide div until the render is complete\n        this.dragDiv!.style.visibility = \"hidden\";\n        this.dragRectRendered = false;\n        this.showPortal(\n            <DragRectRenderWrapper\n                // wait for it to be rendered\n                onRendered={() => {\n                    this.dragRectRendered = true;\n                    onRendered?.();\n                }}>\n                {content}\n            </DragRectRenderWrapper>,\n            this.dragDiv!);\n    };\n\n    /** @internal */\n    showPortal = (control: React.ReactNode, element: HTMLElement) => {\n        const portal = ReactDOM.createPortal(control, element);\n        this.setState({ portal });\n    };\n\n    /** @internal */\n    hidePortal = () => {\n        this.setState({ portal: undefined });\n    };\n\n    /** @internal */\n    onDragStart = () => {\n        this.dropInfo = undefined;\n        this.customDrop = undefined;\n        const rootdiv = this.selfRef.current!;\n        this.outlineDiv = this.currentDocument!.createElement(\"div\");\n        this.outlineDiv.className = this.getClassName(CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n        this.outlineDiv.style.visibility = \"hidden\";\n        rootdiv.appendChild(this.outlineDiv);\n\n        if (this.dragDiv == null) {\n            this.dragDiv = this.currentDocument!.createElement(\"div\");\n            this.dragDiv.className = this.getClassName(CLASSES.FLEXLAYOUT__DRAG_RECT);\n            this.dragDiv.setAttribute(\"data-layout-path\", \"/drag-rectangle\");\n            this.dragRectRender(this.dragDivText, this.dragNode, this.newTabJson);\n\n            rootdiv.appendChild(this.dragDiv);\n        }\n        // add edge indicators\n        this.showEdges(rootdiv);\n\n        if (this.dragNode !== undefined && this.dragNode instanceof TabNode && this.dragNode.getTabRect() !== undefined) {\n            this.dragNode.getTabRect()!.positionElement(this.outlineDiv);\n        }\n        this.firstMove = true;\n\n        return true;\n    };\n\n    /** @internal */\n    onDragMove = (event: React.MouseEvent<Element>) => {\n        if (this.firstMove === false) {\n            const speed = this.props.model._getAttribute(\"tabDragSpeed\") as number;\n            this.outlineDiv!.style.transition = `top ${speed}s, left ${speed}s, width ${speed}s, height ${speed}s`;\n        }\n        this.firstMove = false;\n        const clientRect = this.selfRef.current!.getBoundingClientRect();\n        const pos = {\n            x: event.clientX - clientRect.left,\n            y: event.clientY - clientRect.top,\n        };\n\n        this.checkForBorderToShow(pos.x, pos.y);\n\n        // keep it between left & right\n        const dragRect = this.dragDiv!.getBoundingClientRect();\n        let newLeft = pos.x - dragRect.width / 2;\n        if (newLeft + dragRect.width > clientRect.width) {\n            newLeft = clientRect.width - dragRect.width;\n        }\n        newLeft = Math.max(0, newLeft);\n\n        this.dragDiv!.style.left = newLeft + \"px\";\n        this.dragDiv!.style.top = pos.y + 5 + \"px\";\n        if (this.dragRectRendered && this.dragDiv!.style.visibility === \"hidden\") {\n            // make visible once the drag rect has been rendered\n            this.dragDiv!.style.visibility = \"visible\";\n        }\n\n        let dropInfo = this.props.model._findDropTargetNode(this.dragNode!, pos.x, pos.y);\n        if (dropInfo) {\n            if (this.props.onTabDrag) {\n                this.handleCustomTabDrag(dropInfo, pos, event);\n            } else {\n                this.dropInfo = dropInfo;\n                this.outlineDiv!.className = this.getClassName(dropInfo.className);\n                dropInfo.rect.positionElement(this.outlineDiv!);\n                this.outlineDiv!.style.visibility = \"visible\";\n            }\n        }\n    };\n\n    /** @internal */\n    onDragEnd = (event: Event) => {\n        const rootdiv = this.selfRef.current!;\n        rootdiv.removeChild(this.outlineDiv!);\n        rootdiv.removeChild(this.dragDiv!);\n        this.dragDiv = undefined;\n        this.hidePortal();\n\n        this.hideEdges(rootdiv);\n        DragDrop.instance.hideGlass();\n\n        if (this.dropInfo) {\n            if (this.customDrop) {\n                this.newTabJson = undefined;\n\n                try {\n                    const { callback, dragging, over, x, y, location } = this.customDrop;\n                    callback(dragging, over, x, y, location);\n                    if (this.fnNewNodeDropped != null) {\n                        this.fnNewNodeDropped();\n                        this.fnNewNodeDropped = undefined;\n                    }\n                } catch (e) {\n                    console.error(e)\n                }\n            } else if (this.newTabJson !== undefined) {\n                const newNode = this.doAction(Actions.addNode(this.newTabJson, this.dropInfo.node.getId(), this.dropInfo.location, this.dropInfo.index));\n\n                if (this.fnNewNodeDropped != null) {\n                    this.fnNewNodeDropped(newNode, event);\n                    this.fnNewNodeDropped = undefined;\n                }\n                this.newTabJson = undefined;\n            } else if (this.dragNode !== undefined) {\n                this.doAction(Actions.moveNode(this.dragNode.getId(), this.dropInfo.node.getId(), this.dropInfo.location, this.dropInfo.index));\n            }\n        }\n        this.setState({ showHiddenBorder: DockLocation.CENTER });\n    };\n\n    /** @internal */\n    private handleCustomTabDrag(dropInfo: DropInfo, pos: { x: number; y: number; }, event: React.MouseEvent<Element, MouseEvent>) {\n        let invalidated = this.customDrop?.invalidated;\n        const currentCallback = this.customDrop?.callback;\n        this.customDrop = undefined;\n\n        const dragging = this.newTabJson || (this.dragNode instanceof TabNode ? this.dragNode : undefined);\n        if (dragging && (dropInfo.node instanceof TabSetNode || dropInfo.node instanceof BorderNode) && dropInfo.index === -1) {\n            const selected = dropInfo.node.getSelectedNode() as TabNode | undefined;\n            const tabRect = selected?.getRect();\n\n            if (selected && tabRect?.contains(pos.x, pos.y)) {\n                let customDrop: ICustomDropDestination | undefined = undefined;\n\n                try {\n                    const dest = this.onTabDrag(dragging, selected, pos.x - tabRect.x, pos.y - tabRect.y, dropInfo.location, () => this.onDragMove(event));\n\n                    if (dest) {\n                        customDrop = {\n                            rect: new Rect(dest.x + tabRect.x, dest.y + tabRect.y, dest.width, dest.height),\n                            callback: dest.callback,\n                            invalidated: dest.invalidated,\n                            dragging: dragging,\n                            over: selected,\n                            x: pos.x - tabRect.x,\n                            y: pos.y - tabRect.y,\n                            location: dropInfo.location,\n                            cursor: dest.cursor\n                        };\n                    }\n                } catch (e) {\n                    console.error(e);\n                }\n\n                if (customDrop?.callback === currentCallback) {\n                    invalidated = undefined;\n                }\n\n                this.customDrop = customDrop;\n            }\n        }\n\n        this.dropInfo = dropInfo;\n        this.outlineDiv!.className = this.getClassName(this.customDrop ? CLASSES.FLEXLAYOUT__OUTLINE_RECT : dropInfo.className);\n\n        if (this.customDrop) {\n            this.customDrop.rect.positionElement(this.outlineDiv!);\n        } else {\n            dropInfo.rect.positionElement(this.outlineDiv!);\n        }\n\n        DragDrop.instance.setGlassCursorOverride(this.customDrop?.cursor);\n        this.outlineDiv!.style.visibility = \"visible\";\n\n        try {\n            invalidated?.();\n        } catch (e) {\n            console.error(e);\n        }\n    }\n\n    /** @internal */\n    onDragEnter(event: React.DragEvent<HTMLDivElement>) {\n        // DragDrop keeps track of number of dragenters minus the number of\n        // dragleaves. Only start a new drag if there isn't one already.\n        if (DragDrop.instance.isDragging())\n            return;\n        const drag = this.props.onExternalDrag!(event);\n        if (drag) {\n            // Mimic addTabWithDragAndDrop, but pass in DragEvent\n            this.fnNewNodeDropped = drag.onDrop;\n            this.newTabJson = drag.json;\n            this.dragStart(event, drag.dragText, TabNode._fromJson(drag.json, this.props.model, false), true, undefined, undefined);\n        }\n    }\n\n\n    /** @internal */\n    checkForBorderToShow(x: number, y: number) {\n        const r = this.props.model._getOuterInnerRects().outer;\n        const c = r.getCenter();\n        const margin = this.edgeRectWidth;\n        const offset = this.edgeRectLength / 2;\n\n        let overEdge = false;\n        if (this.props.model.isEnableEdgeDock() && this.state.showHiddenBorder === DockLocation.CENTER) {\n            if ((y > c.y - offset && y < c.y + offset) ||\n                (x > c.x - offset && x < c.x + offset)) {\n                overEdge = true;\n            }\n        }\n\n        let location = DockLocation.CENTER;\n        if (!overEdge) {\n            if (x <= r.x + margin) {\n                location = DockLocation.LEFT;\n            } else if (x >= r.getRight() - margin) {\n                location = DockLocation.RIGHT;\n            } else if (y <= r.y + margin) {\n                location = DockLocation.TOP;\n            } else if (y >= r.getBottom() - margin) {\n                location = DockLocation.BOTTOM;\n            }\n        }\n\n        if (location !== this.state.showHiddenBorder) {\n            this.setState({ showHiddenBorder: location });\n        }\n    }\n\n    /** @internal */\n    showEdges(rootdiv: HTMLElement) {\n        if (this.props.model.isEnableEdgeDock()) {\n            const length = this.edgeRectLength + \"px\";\n            const radius = \"50px\";\n            const width = this.edgeRectWidth + \"px\";\n\n            this.edgeTopDiv = this.currentDocument!.createElement(\"div\");\n            this.edgeTopDiv.className = this.getClassName(CLASSES.FLEXLAYOUT__EDGE_RECT);\n            this.edgeTopDiv.style.width = length;\n            this.edgeTopDiv.style.height = width;\n            this.edgeTopDiv.style.borderBottomLeftRadius = radius;\n            this.edgeTopDiv.style.borderBottomRightRadius = radius;\n\n            this.edgeLeftDiv = this.currentDocument!.createElement(\"div\");\n            this.edgeLeftDiv.className = this.getClassName(CLASSES.FLEXLAYOUT__EDGE_RECT);\n            this.edgeLeftDiv.style.width = width;\n            this.edgeLeftDiv.style.height = length;\n            this.edgeLeftDiv.style.borderTopRightRadius = radius;\n            this.edgeLeftDiv.style.borderBottomRightRadius = radius;\n\n            this.edgeBottomDiv = this.currentDocument!.createElement(\"div\");\n            this.edgeBottomDiv.className = this.getClassName(CLASSES.FLEXLAYOUT__EDGE_RECT);\n            this.edgeBottomDiv.style.width = length;\n            this.edgeBottomDiv.style.height = width;\n            this.edgeBottomDiv.style.borderTopLeftRadius = radius;\n            this.edgeBottomDiv.style.borderTopRightRadius = radius;\n\n            this.edgeRightDiv = this.currentDocument!.createElement(\"div\");\n            this.edgeRightDiv.className = this.getClassName(CLASSES.FLEXLAYOUT__EDGE_RECT);\n            this.edgeRightDiv.style.width = width;\n            this.edgeRightDiv.style.height = length;\n            this.edgeRightDiv.style.borderTopLeftRadius = radius;\n            this.edgeRightDiv.style.borderBottomLeftRadius = radius;\n\n            this.repositionEdges(this.state.rect);\n\n            rootdiv.appendChild(this.edgeTopDiv);\n            rootdiv.appendChild(this.edgeLeftDiv);\n            rootdiv.appendChild(this.edgeBottomDiv);\n            rootdiv.appendChild(this.edgeRightDiv);\n\n            this.edgesShown = true;\n        }\n    }\n\n    /** @internal */\n    repositionEdges(domRect: Rect) {\n        if (this.props.model.isEnableEdgeDock()) {\n            const r = this.centerRect!;\n\n            this.edgeTopDiv!.style.top = r.y + \"px\";\n            this.edgeTopDiv!.style.left = r.x + (r.width - this.edgeRectLength) / 2 + \"px\";\n\n            this.edgeLeftDiv!.style.top = r.y + (r.height - this.edgeRectLength) / 2 + \"px\";\n            this.edgeLeftDiv!.style.left = r.x + \"px\";\n\n            this.edgeBottomDiv!.style.bottom = domRect.height - r.getBottom() + \"px\";\n            this.edgeBottomDiv!.style.left = r.x + (r.width - this.edgeRectLength) / 2 + \"px\";\n\n            this.edgeRightDiv!.style.top = r.y + (r.height - this.edgeRectLength) / 2 + \"px\";\n            this.edgeRightDiv!.style.right = domRect.width - r.getRight() + \"px\";\n        }\n    }\n\n    /** @internal */\n    hideEdges(rootdiv: HTMLElement) {\n        if (this.props.model.isEnableEdgeDock()) {\n            try {\n                rootdiv.removeChild(this.edgeTopDiv!);\n                rootdiv.removeChild(this.edgeLeftDiv!);\n                rootdiv.removeChild(this.edgeBottomDiv!);\n                rootdiv.removeChild(this.edgeRightDiv!);\n            } catch (e) { }\n        }\n\n        this.edgesShown = false;\n    }\n\n    /** @internal */\n    maximize(tabsetNode: TabSetNode) {\n        this.doAction(Actions.maximizeToggle(tabsetNode.getId()));\n    }\n\n    /** @internal */\n    customizeTab(\n        tabNode: TabNode,\n        renderValues: ITabRenderValues,\n    ) {\n        if (this.props.onRenderTab) {\n            this.props.onRenderTab(tabNode, renderValues);\n        }\n    }\n\n    /** @internal */\n    customizeTabSet(\n        tabSetNode: TabSetNode | BorderNode,\n        renderValues: ITabSetRenderValues,\n    ) {\n        if (this.props.onRenderTabSet) {\n            this.props.onRenderTabSet(tabSetNode, renderValues);\n        }\n    }\n\n    /** @internal */\n    i18nName(id: I18nLabel, param?: string) {\n        let message;\n        if (this.props.i18nMapper) {\n            message = this.props.i18nMapper(id, param);\n        }\n        if (message === undefined) {\n            message = id + (param === undefined ? \"\" : param);\n        }\n        return message;\n    }\n\n    /** @internal */\n    getOnRenderFloatingTabPlaceholder() {\n        return this.props.onRenderFloatingTabPlaceholder;\n    }\n\n    /** @internal */\n    getShowOverflowMenu() {\n        return this.props.onShowOverflowMenu;\n    }\n\n    /** @internal */\n    getTabSetPlaceHolderCallback() {\n        return this.props.onTabSetPlaceHolder;\n    }\n    /** @internal */\n    showContextMenu(node: TabNode | TabSetNode | BorderNode, event: React.MouseEvent<HTMLElement, MouseEvent>) {\n        if (this.props.onContextMenu) {\n            this.props.onContextMenu(node, event);\n        }\n    }\n\n    /** @internal */\n    auxMouseClick(node: TabNode | TabSetNode | BorderNode, event: React.MouseEvent<HTMLElement, MouseEvent>) {\n        if (this.props.onAuxMouseClick) {\n            this.props.onAuxMouseClick(node, event);\n        }\n    }\n}\n\n// wrapper round the drag rect renderer that can call\n// a method once the rendering is written to the dom\n\n/** @internal */\ninterface IDragRectRenderWrapper {\n    onRendered?: () => void;\n    children: React.ReactNode;\n}\n\n/** @internal */\nconst DragRectRenderWrapper = (props: IDragRectRenderWrapper) => {\n    React.useEffect(() => {\n        props.onRendered?.();\n    }, [props]);\n\n    return (<React.Fragment>\n        {props.children}\n    </React.Fragment>)\n}\n"]},"metadata":{},"sourceType":"script"}