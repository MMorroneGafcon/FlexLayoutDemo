{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BorderNode = void 0;\n\nvar Attribute_1 = require(\"../Attribute\");\n\nvar AttributeDefinitions_1 = require(\"../AttributeDefinitions\");\n\nvar DockLocation_1 = require(\"../DockLocation\");\n\nvar DropInfo_1 = require(\"../DropInfo\");\n\nvar Orientation_1 = require(\"../Orientation\");\n\nvar Rect_1 = require(\"../Rect\");\n\nvar Types_1 = require(\"../Types\");\n\nvar Node_1 = require(\"./Node\");\n\nvar SplitterNode_1 = require(\"./SplitterNode\");\n\nvar TabNode_1 = require(\"./TabNode\");\n\nvar Utils_1 = require(\"./Utils\");\n\nvar BorderNode =\n/** @class */\nfunction (_super) {\n  __extends(BorderNode, _super);\n  /** @internal */\n\n\n  function BorderNode(location, json, model) {\n    var _this = _super.call(this, model) || this;\n    /** @internal */\n\n\n    _this._adjustedSize = 0;\n    /** @internal */\n\n    _this._calculatedBorderBarSize = 0;\n    _this._location = location;\n    _this._drawChildren = [];\n    _this._attributes.id = \"border_\".concat(location.getName());\n\n    BorderNode._attributeDefinitions.fromJson(json, _this._attributes);\n\n    model._addNode(_this);\n\n    return _this;\n  }\n  /** @internal */\n\n\n  BorderNode._fromJson = function (json, model) {\n    var location = DockLocation_1.DockLocation.getByName(json.location);\n    var border = new BorderNode(location, json, model);\n\n    if (json.children) {\n      border._children = json.children.map(function (jsonChild) {\n        var child = TabNode_1.TabNode._fromJson(jsonChild, model);\n\n        child._setParent(border);\n\n        return child;\n      });\n    }\n\n    return border;\n  };\n  /** @internal */\n\n\n  BorderNode._createAttributeDefinitions = function () {\n    var attributeDefinitions = new AttributeDefinitions_1.AttributeDefinitions();\n    attributeDefinitions.add(\"type\", BorderNode.TYPE, true).setType(Attribute_1.Attribute.STRING).setFixed();\n    attributeDefinitions.add(\"selected\", -1).setType(Attribute_1.Attribute.NUMBER);\n    attributeDefinitions.add(\"show\", true).setType(Attribute_1.Attribute.BOOLEAN);\n    attributeDefinitions.add(\"config\", undefined).setType(\"any\");\n    attributeDefinitions.addInherited(\"barSize\", \"borderBarSize\").setType(Attribute_1.Attribute.NUMBER);\n    attributeDefinitions.addInherited(\"enableDrop\", \"borderEnableDrop\").setType(Attribute_1.Attribute.BOOLEAN);\n    attributeDefinitions.addInherited(\"className\", \"borderClassName\").setType(Attribute_1.Attribute.STRING);\n    attributeDefinitions.addInherited(\"autoSelectTabWhenOpen\", \"borderAutoSelectTabWhenOpen\").setType(Attribute_1.Attribute.BOOLEAN);\n    attributeDefinitions.addInherited(\"autoSelectTabWhenClosed\", \"borderAutoSelectTabWhenClosed\").setType(Attribute_1.Attribute.BOOLEAN);\n    attributeDefinitions.addInherited(\"size\", \"borderSize\").setType(Attribute_1.Attribute.NUMBER);\n    attributeDefinitions.addInherited(\"minSize\", \"borderMinSize\").setType(Attribute_1.Attribute.NUMBER);\n    attributeDefinitions.addInherited(\"enableAutoHide\", \"borderEnableAutoHide\").setType(Attribute_1.Attribute.BOOLEAN);\n    return attributeDefinitions;\n  };\n\n  BorderNode.prototype.getLocation = function () {\n    return this._location;\n  };\n\n  BorderNode.prototype.getTabHeaderRect = function () {\n    return this._tabHeaderRect;\n  };\n\n  BorderNode.prototype.getRect = function () {\n    return this._tabHeaderRect;\n  };\n\n  BorderNode.prototype.getContentRect = function () {\n    return this._contentRect;\n  };\n\n  BorderNode.prototype.isEnableDrop = function () {\n    return this._getAttr(\"enableDrop\");\n  };\n\n  BorderNode.prototype.isAutoSelectTab = function (whenOpen) {\n    if (whenOpen == null) {\n      whenOpen = this.getSelected() !== -1;\n    }\n\n    if (whenOpen) {\n      return this._getAttr(\"autoSelectTabWhenOpen\");\n    } else {\n      return this._getAttr(\"autoSelectTabWhenClosed\");\n    }\n  };\n\n  BorderNode.prototype.getClassName = function () {\n    return this._getAttr(\"className\");\n  };\n  /** @internal */\n\n\n  BorderNode.prototype.calcBorderBarSize = function (metrics) {\n    var barSize = this._getAttr(\"barSize\");\n\n    if (barSize !== 0) {\n      // its defined\n      this._calculatedBorderBarSize = barSize;\n    } else {\n      this._calculatedBorderBarSize = metrics.borderBarSize;\n    }\n  };\n\n  BorderNode.prototype.getBorderBarSize = function () {\n    return this._calculatedBorderBarSize;\n  };\n\n  BorderNode.prototype.getSize = function () {\n    var defaultSize = this._getAttr(\"size\");\n\n    var selected = this.getSelected();\n\n    if (selected === -1) {\n      return defaultSize;\n    } else {\n      var tabNode = this._children[selected];\n      var tabBorderSize = this._location._orientation === Orientation_1.Orientation.HORZ ? tabNode._getAttr(\"borderWidth\") : tabNode._getAttr(\"borderHeight\");\n\n      if (tabBorderSize === -1) {\n        return defaultSize;\n      } else {\n        return tabBorderSize;\n      }\n    }\n  };\n\n  BorderNode.prototype.getMinSize = function () {\n    return this._getAttr(\"minSize\");\n  };\n\n  BorderNode.prototype.getSelected = function () {\n    return this._attributes.selected;\n  };\n\n  BorderNode.prototype.getSelectedNode = function () {\n    if (this.getSelected() !== -1) {\n      return this._children[this.getSelected()];\n    }\n\n    return undefined;\n  };\n\n  BorderNode.prototype.getOrientation = function () {\n    return this._location.getOrientation();\n  };\n  /**\n   * Returns the config attribute that can be used to store node specific data that\n   * WILL be saved to the json. The config attribute should be changed via the action Actions.updateNodeAttributes rather\n   * than directly, for example:\n   * this.state.model.doAction(\n   *   FlexLayout.Actions.updateNodeAttributes(node.getId(), {config:myConfigObject}));\n   */\n\n\n  BorderNode.prototype.getConfig = function () {\n    return this._attributes.config;\n  };\n\n  BorderNode.prototype.isMaximized = function () {\n    return false;\n  };\n\n  BorderNode.prototype.isShowing = function () {\n    var show = this._attributes.show;\n\n    if (show) {\n      if (this._model._getShowHiddenBorder() !== this._location && this.isAutoHide() && this._children.length === 0) {\n        return false;\n      }\n\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  BorderNode.prototype.isAutoHide = function () {\n    return this._getAttr(\"enableAutoHide\");\n  };\n  /** @internal */\n\n\n  BorderNode.prototype._setSelected = function (index) {\n    this._attributes.selected = index;\n  };\n  /** @internal */\n\n\n  BorderNode.prototype._setSize = function (pos) {\n    var selected = this.getSelected();\n\n    if (selected === -1) {\n      this._attributes.size = pos;\n    } else {\n      var tabNode = this._children[selected];\n      var tabBorderSize = this._location._orientation === Orientation_1.Orientation.HORZ ? tabNode._getAttr(\"borderWidth\") : tabNode._getAttr(\"borderHeight\");\n\n      if (tabBorderSize === -1) {\n        this._attributes.size = pos;\n      } else {\n        if (this._location._orientation === Orientation_1.Orientation.HORZ) {\n          tabNode._setBorderWidth(pos);\n        } else {\n          tabNode._setBorderHeight(pos);\n        }\n      }\n    }\n  };\n  /** @internal */\n\n\n  BorderNode.prototype._updateAttrs = function (json) {\n    BorderNode._attributeDefinitions.update(json, this._attributes);\n  };\n  /** @internal */\n\n\n  BorderNode.prototype._getDrawChildren = function () {\n    return this._drawChildren;\n  };\n  /** @internal */\n\n\n  BorderNode.prototype._setAdjustedSize = function (size) {\n    this._adjustedSize = size;\n  };\n  /** @internal */\n\n\n  BorderNode.prototype._getAdjustedSize = function () {\n    return this._adjustedSize;\n  };\n  /** @internal */\n\n\n  BorderNode.prototype._layoutBorderOuter = function (outer, metrics) {\n    this.calcBorderBarSize(metrics);\n\n    var split1 = this._location.split(outer, this.getBorderBarSize()); // split border outer\n\n\n    this._tabHeaderRect = split1.start;\n    return split1.end;\n  };\n  /** @internal */\n\n\n  BorderNode.prototype._layoutBorderInner = function (inner, metrics) {\n    this._drawChildren = [];\n    var location = this._location;\n    var split1 = location.split(inner, this._adjustedSize + this._model.getSplitterSize()); // split off tab contents\n\n    var split2 = location.reflect().split(split1.start, this._model.getSplitterSize()); // split contents into content and splitter\n\n    this._contentRect = split2.end;\n\n    for (var i = 0; i < this._children.length; i++) {\n      var child = this._children[i];\n\n      child._layout(this._contentRect, metrics);\n\n      child._setVisible(i === this.getSelected());\n\n      this._drawChildren.push(child);\n    }\n\n    if (this.getSelected() === -1) {\n      return inner;\n    } else {\n      var newSplitter = new SplitterNode_1.SplitterNode(this._model);\n\n      newSplitter._setParent(this);\n\n      newSplitter._setRect(split2.start);\n\n      this._drawChildren.push(newSplitter);\n\n      return split1.end;\n    }\n  };\n  /** @internal */\n\n\n  BorderNode.prototype._remove = function (node) {\n    var removedIndex = this._removeChild(node);\n\n    if (this.getSelected() !== -1) {\n      (0, Utils_1.adjustSelectedIndex)(this, removedIndex);\n    }\n  };\n  /** @internal */\n\n\n  BorderNode.prototype.canDrop = function (dragNode, x, y) {\n    if (dragNode.getType() !== TabNode_1.TabNode.TYPE) {\n      return undefined;\n    }\n\n    var dropInfo;\n    var dockLocation = DockLocation_1.DockLocation.CENTER;\n\n    if (this._tabHeaderRect.contains(x, y)) {\n      if (this._location._orientation === Orientation_1.Orientation.VERT) {\n        if (this._children.length > 0) {\n          var child = this._children[0];\n          var childRect = child.getTabRect();\n          var childY = childRect.y;\n          var childHeight = childRect.height;\n          var pos = this._tabHeaderRect.x;\n          var childCenter = 0;\n\n          for (var i = 0; i < this._children.length; i++) {\n            child = this._children[i];\n            childRect = child.getTabRect();\n            childCenter = childRect.x + childRect.width / 2;\n\n            if (x >= pos && x < childCenter) {\n              var outlineRect = new Rect_1.Rect(childRect.x - 2, childY, 3, childHeight);\n              dropInfo = new DropInfo_1.DropInfo(this, outlineRect, dockLocation, i, Types_1.CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n              break;\n            }\n\n            pos = childCenter;\n          }\n\n          if (dropInfo == null) {\n            var outlineRect = new Rect_1.Rect(childRect.getRight() - 2, childY, 3, childHeight);\n            dropInfo = new DropInfo_1.DropInfo(this, outlineRect, dockLocation, this._children.length, Types_1.CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n          }\n        } else {\n          var outlineRect = new Rect_1.Rect(this._tabHeaderRect.x + 1, this._tabHeaderRect.y + 2, 3, 18);\n          dropInfo = new DropInfo_1.DropInfo(this, outlineRect, dockLocation, 0, Types_1.CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n        }\n      } else {\n        if (this._children.length > 0) {\n          var child = this._children[0];\n          var childRect = child.getTabRect();\n          var childX = childRect.x;\n          var childWidth = childRect.width;\n          var pos = this._tabHeaderRect.y;\n          var childCenter = 0;\n\n          for (var i = 0; i < this._children.length; i++) {\n            child = this._children[i];\n            childRect = child.getTabRect();\n            childCenter = childRect.y + childRect.height / 2;\n\n            if (y >= pos && y < childCenter) {\n              var outlineRect = new Rect_1.Rect(childX, childRect.y - 2, childWidth, 3);\n              dropInfo = new DropInfo_1.DropInfo(this, outlineRect, dockLocation, i, Types_1.CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n              break;\n            }\n\n            pos = childCenter;\n          }\n\n          if (dropInfo == null) {\n            var outlineRect = new Rect_1.Rect(childX, childRect.getBottom() - 2, childWidth, 3);\n            dropInfo = new DropInfo_1.DropInfo(this, outlineRect, dockLocation, this._children.length, Types_1.CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n          }\n        } else {\n          var outlineRect = new Rect_1.Rect(this._tabHeaderRect.x + 2, this._tabHeaderRect.y + 1, 18, 3);\n          dropInfo = new DropInfo_1.DropInfo(this, outlineRect, dockLocation, 0, Types_1.CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n        }\n      }\n\n      if (!dragNode._canDockInto(dragNode, dropInfo)) {\n        return undefined;\n      }\n    } else if (this.getSelected() !== -1 && this._contentRect.contains(x, y)) {\n      var outlineRect = this._contentRect;\n      dropInfo = new DropInfo_1.DropInfo(this, outlineRect, dockLocation, -1, Types_1.CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n\n      if (!dragNode._canDockInto(dragNode, dropInfo)) {\n        return undefined;\n      }\n    }\n\n    return dropInfo;\n  };\n  /** @internal */\n\n\n  BorderNode.prototype.drop = function (dragNode, location, index, select) {\n    var fromIndex = 0;\n    var dragParent = dragNode.getParent();\n\n    if (dragParent !== undefined) {\n      fromIndex = dragParent._removeChild(dragNode);\n      (0, Utils_1.adjustSelectedIndex)(dragParent, fromIndex);\n    } // if dropping a tab back to same tabset and moving to forward position then reduce insertion index\n\n\n    if (dragNode.getType() === TabNode_1.TabNode.TYPE && dragParent === this && fromIndex < index && index > 0) {\n      index--;\n    } // simple_bundled dock to existing tabset\n\n\n    var insertPos = index;\n\n    if (insertPos === -1) {\n      insertPos = this._children.length;\n    }\n\n    if (dragNode.getType() === TabNode_1.TabNode.TYPE) {\n      this._addChild(dragNode, insertPos);\n    }\n\n    if (select || select !== false && this.isAutoSelectTab()) {\n      this._setSelected(insertPos);\n    }\n\n    this._model._tidy();\n  };\n\n  BorderNode.prototype.toJson = function () {\n    var json = {};\n\n    BorderNode._attributeDefinitions.toJson(json, this._attributes);\n\n    json.location = this._location.getName();\n    json.children = this._children.map(function (child) {\n      return child.toJson();\n    });\n    return json;\n  };\n  /** @internal */\n\n\n  BorderNode.prototype._getSplitterBounds = function (splitter, useMinSize) {\n    if (useMinSize === void 0) {\n      useMinSize = false;\n    }\n\n    var pBounds = [0, 0];\n    var minSize = useMinSize ? this.getMinSize() : 0;\n\n    var outerRect = this._model._getOuterInnerRects().outer;\n\n    var innerRect = this._model._getOuterInnerRects().inner;\n\n    var rootRow = this._model.getRoot();\n\n    if (this._location === DockLocation_1.DockLocation.TOP) {\n      pBounds[0] = outerRect.y + minSize;\n      pBounds[1] = Math.max(pBounds[0], innerRect.getBottom() - splitter.getHeight() - rootRow.getMinHeight());\n    } else if (this._location === DockLocation_1.DockLocation.LEFT) {\n      pBounds[0] = outerRect.x + minSize;\n      pBounds[1] = Math.max(pBounds[0], innerRect.getRight() - splitter.getWidth() - rootRow.getMinWidth());\n    } else if (this._location === DockLocation_1.DockLocation.BOTTOM) {\n      pBounds[1] = outerRect.getBottom() - splitter.getHeight() - minSize;\n      pBounds[0] = Math.min(pBounds[1], innerRect.y + rootRow.getMinHeight());\n    } else if (this._location === DockLocation_1.DockLocation.RIGHT) {\n      pBounds[1] = outerRect.getRight() - splitter.getWidth() - minSize;\n      pBounds[0] = Math.min(pBounds[1], innerRect.x + rootRow.getMinWidth());\n    }\n\n    return pBounds;\n  };\n  /** @internal */\n\n\n  BorderNode.prototype._calculateSplit = function (splitter, splitterPos) {\n    var pBounds = this._getSplitterBounds(splitter);\n\n    if (this._location === DockLocation_1.DockLocation.BOTTOM || this._location === DockLocation_1.DockLocation.RIGHT) {\n      return Math.max(0, pBounds[1] - splitterPos);\n    } else {\n      return Math.max(0, splitterPos - pBounds[0]);\n    }\n  };\n  /** @internal */\n\n\n  BorderNode.prototype._getAttributeDefinitions = function () {\n    return BorderNode._attributeDefinitions;\n  };\n  /** @internal */\n\n\n  BorderNode.getAttributeDefinitions = function () {\n    return BorderNode._attributeDefinitions;\n  };\n\n  BorderNode.TYPE = \"border\";\n  /** @internal */\n\n  BorderNode._attributeDefinitions = BorderNode._createAttributeDefinitions();\n  return BorderNode;\n}(Node_1.Node);\n\nexports.BorderNode = BorderNode;","map":{"version":3,"mappings":"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","names":["__extends","location","json","model","_super","_this","_location","_drawChildren","_attributes","id","getName","BorderNode","_attributeDefinitions","fromJson","_addNode","DockLocation_1","getByName","border","children","_children","map","jsonChild","child","TabNode_1","_fromJson","_setParent","attributeDefinitions","AttributeDefinitions_1","add","TYPE","setType","Attribute_1","STRING","setFixed","NUMBER","BOOLEAN","undefined","addInherited","_tabHeaderRect","_contentRect","_getAttr","whenOpen","getSelected","metrics","barSize","_calculatedBorderBarSize","borderBarSize","defaultSize","selected","tabNode","tabBorderSize","_orientation","Orientation_1","HORZ","getOrientation","config","show","_model","_getShowHiddenBorder","isAutoHide","length","index","pos","size","_setBorderWidth","_setBorderHeight","update","_adjustedSize","outer","calcBorderBarSize","split1","split","getBorderBarSize","start","end","inner","getSplitterSize","split2","reflect","i","_layout","_setVisible","push","newSplitter","SplitterNode_1","_setRect","node","removedIndex","_removeChild","dragNode","x","y","getType","dropInfo","dockLocation","CENTER","contains","VERT","childRect","getTabRect","childY","childHeight","height","childCenter","width","outlineRect","Rect_1","DropInfo_1","Types_1","FLEXLAYOUT__OUTLINE_RECT","getRight","childX","childWidth","getBottom","_canDockInto","select","fromIndex","dragParent","getParent","insertPos","_addChild","isAutoSelectTab","_setSelected","_tidy","toJson","splitter","useMinSize","pBounds","minSize","getMinSize","outerRect","_getOuterInnerRects","innerRect","rootRow","getRoot","TOP","Math","max","getHeight","getMinHeight","LEFT","getWidth","getMinWidth","BOTTOM","min","RIGHT","splitterPos","_getSplitterBounds","_createAttributeDefinitions","Node_1","exports"],"sources":["C:\\Users\\mmorrone\\UnityProjects\\my-app\\node_modules\\flexlayout-react\\src\\model\\BorderNode.ts"],"sourcesContent":["import { Attribute } from \"../Attribute\";\nimport { AttributeDefinitions } from \"../AttributeDefinitions\";\nimport { DockLocation } from \"../DockLocation\";\nimport { DropInfo } from \"../DropInfo\";\nimport { Orientation } from \"../Orientation\";\nimport { Rect } from \"../Rect\";\nimport { CLASSES } from \"../Types\";\nimport { IDraggable } from \"./IDraggable\";\nimport { IDropTarget } from \"./IDropTarget\";\nimport { IJsonBorderNode } from \"./IJsonModel\";\nimport { Model, ILayoutMetrics } from \"./Model\";\nimport { Node } from \"./Node\";\nimport { SplitterNode } from \"./SplitterNode\";\nimport { TabNode } from \"./TabNode\";\nimport { TabSetNode } from \"./TabSetNode\";\nimport { adjustSelectedIndex } from \"./Utils\";\n\nexport class BorderNode extends Node implements IDropTarget {\n    static readonly TYPE = \"border\";\n\n    /** @internal */\n    static _fromJson(json: any, model: Model) {\n        const location = DockLocation.getByName(json.location);\n        const border = new BorderNode(location, json, model);\n        if (json.children) {\n            border._children = json.children.map((jsonChild: any) => {\n                const child = TabNode._fromJson(jsonChild, model);\n                child._setParent(border);\n                return child;\n            });\n        }\n\n        return border;\n    }\n    /** @internal */\n    private static _attributeDefinitions: AttributeDefinitions = BorderNode._createAttributeDefinitions();\n\n    /** @internal */\n    private static _createAttributeDefinitions(): AttributeDefinitions {\n        const attributeDefinitions = new AttributeDefinitions();\n        attributeDefinitions.add(\"type\", BorderNode.TYPE, true).setType(Attribute.STRING).setFixed();\n\n        attributeDefinitions.add(\"selected\", -1).setType(Attribute.NUMBER);\n        attributeDefinitions.add(\"show\", true).setType(Attribute.BOOLEAN);\n        attributeDefinitions.add(\"config\", undefined).setType(\"any\");\n\n        attributeDefinitions.addInherited(\"barSize\", \"borderBarSize\").setType(Attribute.NUMBER);\n        attributeDefinitions.addInherited(\"enableDrop\", \"borderEnableDrop\").setType(Attribute.BOOLEAN);\n        attributeDefinitions.addInherited(\"className\", \"borderClassName\").setType(Attribute.STRING);\n        attributeDefinitions.addInherited(\"autoSelectTabWhenOpen\", \"borderAutoSelectTabWhenOpen\").setType(Attribute.BOOLEAN);\n        attributeDefinitions.addInherited(\"autoSelectTabWhenClosed\", \"borderAutoSelectTabWhenClosed\").setType(Attribute.BOOLEAN);\n        attributeDefinitions.addInherited(\"size\", \"borderSize\").setType(Attribute.NUMBER);\n        attributeDefinitions.addInherited(\"minSize\", \"borderMinSize\").setType(Attribute.NUMBER);\n        attributeDefinitions.addInherited(\"enableAutoHide\", \"borderEnableAutoHide\").setType(Attribute.BOOLEAN);\n        return attributeDefinitions;\n    }\n\n    /** @internal */\n    private _contentRect?: Rect;\n    /** @internal */\n    private _tabHeaderRect?: Rect;\n    /** @internal */\n    private _location: DockLocation;\n    /** @internal */\n    private _drawChildren: Node[];\n    /** @internal */\n    private _adjustedSize: number = 0;\n    /** @internal */\n    private _calculatedBorderBarSize: number = 0;\n\n    /** @internal */\n    constructor(location: DockLocation, json: any, model: Model) {\n        super(model);\n\n        this._location = location;\n        this._drawChildren = [];\n        this._attributes.id = `border_${location.getName()}`;\n        BorderNode._attributeDefinitions.fromJson(json, this._attributes);\n        model._addNode(this);\n    }\n\n    getLocation() {\n        return this._location;\n    }\n\n    getTabHeaderRect() {\n        return this._tabHeaderRect;\n    }\n\n    getRect() {\n        return this._tabHeaderRect!;\n    }\n\n    getContentRect() {\n        return this._contentRect;\n    }\n\n    isEnableDrop() {\n        return this._getAttr(\"enableDrop\") as boolean;\n    }\n\n    isAutoSelectTab(whenOpen?: boolean) {\n        if (whenOpen == null) {\n            whenOpen = this.getSelected() !== -1;\n        }\n        if (whenOpen) {\n            return this._getAttr(\"autoSelectTabWhenOpen\") as boolean;\n        } else {\n            return this._getAttr(\"autoSelectTabWhenClosed\") as boolean;\n        }\n    }\n\n    getClassName() {\n        return this._getAttr(\"className\") as string | undefined;\n    }\n\n    /** @internal */\n    calcBorderBarSize(metrics: ILayoutMetrics) {\n        const barSize = this._getAttr(\"barSize\") as number;\n        if (barSize !== 0) {\n            // its defined\n            this._calculatedBorderBarSize = barSize;\n        } else {\n            this._calculatedBorderBarSize = metrics.borderBarSize;\n        }\n    }\n\n    getBorderBarSize() {\n        return this._calculatedBorderBarSize;\n    }\n\n    getSize() {\n        const defaultSize = this._getAttr(\"size\") as number;\n        const selected = this.getSelected();\n        if (selected === -1) {\n            return defaultSize;\n        } else {\n            const tabNode = this._children[selected] as TabNode;\n            const tabBorderSize = (this._location._orientation === Orientation.HORZ) ? tabNode._getAttr(\"borderWidth\") : tabNode._getAttr(\"borderHeight\");\n            if (tabBorderSize === -1) {\n                return defaultSize;\n            } else {\n                return tabBorderSize;\n            }\n        }\n    }\n\n    getMinSize() {\n        return this._getAttr(\"minSize\") as number;\n    }\n\n    getSelected(): number {\n        return this._attributes.selected as number;\n    }\n\n    getSelectedNode(): Node | undefined {\n        if (this.getSelected() !== -1) {\n            return this._children[this.getSelected()];\n        }\n        return undefined;\n    }\n\n    getOrientation() {\n        return this._location.getOrientation();\n    }\n\n    /**\n     * Returns the config attribute that can be used to store node specific data that\n     * WILL be saved to the json. The config attribute should be changed via the action Actions.updateNodeAttributes rather\n     * than directly, for example:\n     * this.state.model.doAction(\n     *   FlexLayout.Actions.updateNodeAttributes(node.getId(), {config:myConfigObject}));\n     */\n    getConfig() {\n        return this._attributes.config;\n    }\n\n    isMaximized() {\n        return false;\n    }\n\n    isShowing() {\n        const show = this._attributes.show as boolean;\n        if (show) {\n            if (this._model._getShowHiddenBorder() !== this._location && this.isAutoHide() && this._children.length === 0) {\n                return false;\n            }\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    isAutoHide() {\n        return this._getAttr(\"enableAutoHide\") as boolean;\n    }\n\n    /** @internal */\n    _setSelected(index: number) {\n        this._attributes.selected = index;\n    }\n\n    /** @internal */\n    _setSize(pos: number) {\n        const selected = this.getSelected();\n        if (selected === -1) {\n            this._attributes.size = pos;\n        } else {\n            const tabNode = this._children[selected] as TabNode;\n            const tabBorderSize = (this._location._orientation === Orientation.HORZ) ? tabNode._getAttr(\"borderWidth\") : tabNode._getAttr(\"borderHeight\");\n            if (tabBorderSize === -1) {\n                this._attributes.size = pos;\n            } else {\n                if (this._location._orientation === Orientation.HORZ) {\n                    tabNode._setBorderWidth(pos);\n                } else {\n                    tabNode._setBorderHeight(pos);\n                }\n            }\n        }\n    }\n\n    /** @internal */\n    _updateAttrs(json: any) {\n        BorderNode._attributeDefinitions.update(json, this._attributes);\n    }\n\n    /** @internal */\n    _getDrawChildren() {\n        return this._drawChildren;\n    }\n\n    /** @internal */\n    _setAdjustedSize(size: number) {\n        this._adjustedSize = size;\n    }\n\n    /** @internal */\n    _getAdjustedSize() {\n        return this._adjustedSize;\n    }\n\n    /** @internal */\n    _layoutBorderOuter(outer: Rect, metrics: ILayoutMetrics) {\n        this.calcBorderBarSize(metrics);\n        const split1 = this._location.split(outer, this.getBorderBarSize()); // split border outer\n        this._tabHeaderRect = split1.start;\n        return split1.end;\n    }\n\n    /** @internal */\n    _layoutBorderInner(inner: Rect, metrics: ILayoutMetrics) {\n        this._drawChildren = [];\n        const location = this._location;\n\n        const split1 = location.split(inner, this._adjustedSize + this._model.getSplitterSize()); // split off tab contents\n        const split2 = location.reflect().split(split1.start, this._model.getSplitterSize()); // split contents into content and splitter\n\n        this._contentRect = split2.end;\n\n        for (let i = 0; i< this._children.length; i++) {\n            const child = this._children[i];\n            child._layout(this._contentRect!, metrics);\n            child._setVisible(i === this.getSelected());\n            this._drawChildren.push(child);\n        }\n\n        if (this.getSelected() === -1) {\n            return inner;\n        } else {\n            const newSplitter = new SplitterNode(this._model);\n            newSplitter._setParent(this);\n            newSplitter._setRect(split2.start);\n            this._drawChildren.push(newSplitter);\n\n            return split1.end;\n        }\n    }\n\n    /** @internal */\n    _remove(node: TabNode) {\n        const removedIndex = this._removeChild(node);\n        if (this.getSelected() !== -1) {\n            adjustSelectedIndex(this, removedIndex);\n        }\n    }\n\n    /** @internal */\n    canDrop(dragNode: Node & IDraggable, x: number, y: number): DropInfo | undefined {\n        if (dragNode.getType() !== TabNode.TYPE) {\n            return undefined;\n        }\n\n        let dropInfo;\n        const dockLocation = DockLocation.CENTER;\n\n        if (this._tabHeaderRect!.contains(x, y)) {\n            if (this._location._orientation === Orientation.VERT) {\n                if (this._children.length > 0) {\n                    let child = this._children[0];\n                    let childRect = (child as TabNode).getTabRect()!;\n                    const childY = childRect.y;\n\n                    const childHeight = childRect.height;\n\n                    let pos = this._tabHeaderRect!.x;\n                    let childCenter = 0;\n                    for (let i = 0; i < this._children.length; i++) {\n                        child = this._children[i];\n                        childRect = (child as TabNode).getTabRect()!;\n                        childCenter = childRect.x + childRect.width / 2;\n                        if (x >= pos && x < childCenter) {\n                            const outlineRect = new Rect(childRect.x - 2, childY, 3, childHeight);\n                            dropInfo = new DropInfo(this, outlineRect, dockLocation, i, CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n                            break;\n                        }\n                        pos = childCenter;\n                    }\n                    if (dropInfo == null) {\n                        const outlineRect = new Rect(childRect.getRight() - 2, childY, 3, childHeight);\n                        dropInfo = new DropInfo(this, outlineRect, dockLocation, this._children.length, CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n                    }\n                } else {\n                    const outlineRect = new Rect(this._tabHeaderRect!.x + 1, this._tabHeaderRect!.y + 2, 3, 18);\n                    dropInfo = new DropInfo(this, outlineRect, dockLocation, 0, CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n                }\n            } else {\n                if (this._children.length > 0) {\n                    let child = this._children[0];\n                    let childRect = (child as TabNode).getTabRect()!;\n                    const childX = childRect.x;\n                    const childWidth = childRect.width;\n\n                    let pos = this._tabHeaderRect!.y;\n                    let childCenter = 0;\n                    for (let i = 0; i < this._children.length; i++) {\n                        child = this._children[i];\n                        childRect = (child as TabNode).getTabRect()!;\n                        childCenter = childRect.y + childRect.height / 2;\n                        if (y >= pos && y < childCenter) {\n                            const outlineRect = new Rect(childX, childRect.y - 2, childWidth, 3);\n                            dropInfo = new DropInfo(this, outlineRect, dockLocation, i, CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n                            break;\n                        }\n                        pos = childCenter;\n                    }\n                    if (dropInfo == null) {\n                        const outlineRect = new Rect(childX, childRect.getBottom() - 2, childWidth, 3);\n                        dropInfo = new DropInfo(this, outlineRect, dockLocation, this._children.length, CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n                    }\n                } else {\n                    const outlineRect = new Rect(this._tabHeaderRect!.x + 2, this._tabHeaderRect!.y + 1, 18, 3);\n                    dropInfo = new DropInfo(this, outlineRect, dockLocation, 0, CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n                }\n            }\n            if (!dragNode._canDockInto(dragNode, dropInfo)) {\n                return undefined;\n            }\n        } else if (this.getSelected() !== -1 && this._contentRect!.contains(x, y)) {\n            const outlineRect = this._contentRect;\n            dropInfo = new DropInfo(this, outlineRect!, dockLocation, -1, CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n            if (!dragNode._canDockInto(dragNode, dropInfo)) {\n                return undefined;\n            }\n        }\n\n        return dropInfo;\n    }\n\n    /** @internal */\n    drop(dragNode: Node & IDraggable, location: DockLocation, index: number, select?: boolean): void {\n        let fromIndex = 0;\n        const dragParent = dragNode.getParent() as BorderNode | TabSetNode;\n        if (dragParent !== undefined) {\n            fromIndex = dragParent._removeChild(dragNode);\n            adjustSelectedIndex(dragParent, fromIndex);\n        }\n\n        // if dropping a tab back to same tabset and moving to forward position then reduce insertion index\n        if (dragNode.getType() === TabNode.TYPE && dragParent === this && fromIndex < index && index > 0) {\n            index--;\n        }\n\n        // simple_bundled dock to existing tabset\n        let insertPos = index;\n        if (insertPos === -1) {\n            insertPos = this._children.length;\n        }\n\n        if (dragNode.getType() === TabNode.TYPE) {\n            this._addChild(dragNode, insertPos);\n        }\n\n        if (select || (select !== false && this.isAutoSelectTab())) {\n            this._setSelected(insertPos);\n        }\n\n        this._model._tidy();\n    }\n\n    toJson(): IJsonBorderNode {\n        const json: any = {};\n        BorderNode._attributeDefinitions.toJson(json, this._attributes);\n        json.location = this._location.getName();\n        json.children = this._children.map((child) => (child as TabNode).toJson());\n        return json;\n    }\n\n    /** @internal */\n    _getSplitterBounds(splitter: SplitterNode, useMinSize: boolean = false) {\n        const pBounds = [0, 0];\n        const minSize = useMinSize ? this.getMinSize() : 0;\n        const outerRect = this._model._getOuterInnerRects().outer;\n        const innerRect = this._model._getOuterInnerRects().inner;\n        const rootRow = this._model.getRoot();\n        if (this._location === DockLocation.TOP) {\n            pBounds[0] = outerRect.y + minSize;\n            pBounds[1] = Math.max(pBounds[0], innerRect.getBottom() - splitter.getHeight() - rootRow.getMinHeight());\n        } else if (this._location === DockLocation.LEFT) {\n            pBounds[0] = outerRect.x + minSize;\n            pBounds[1] = Math.max(pBounds[0], innerRect.getRight() - splitter.getWidth() - rootRow.getMinWidth());\n        } else if (this._location === DockLocation.BOTTOM) {\n            pBounds[1] = outerRect.getBottom() - splitter.getHeight() - minSize;\n            pBounds[0] = Math.min(pBounds[1], innerRect.y + rootRow.getMinHeight());\n        } else if (this._location === DockLocation.RIGHT) {\n            pBounds[1] = outerRect.getRight() - splitter.getWidth() - minSize;\n            pBounds[0] = Math.min(pBounds[1], innerRect.x + rootRow.getMinWidth());\n        }\n        return pBounds;\n    }\n\n    /** @internal */\n    _calculateSplit(splitter: SplitterNode, splitterPos: number) {\n        const pBounds = this._getSplitterBounds(splitter);\n        if (this._location === DockLocation.BOTTOM || this._location === DockLocation.RIGHT) {\n            return Math.max(0, pBounds[1] - splitterPos);\n        } else {\n            return Math.max(0, splitterPos - pBounds[0]);\n        }\n    }\n\n    /** @internal */\n    _getAttributeDefinitions() {\n        return BorderNode._attributeDefinitions;\n    }\n\n    /** @internal */\n    static getAttributeDefinitions() {\n        return BorderNode._attributeDefinitions;\n    }\n\n}\n"]},"metadata":{},"sourceType":"script"}